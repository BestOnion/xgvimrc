C/C++ 语言参考





基本C/C++





预处理命令

操作符优先级

转义字符

ASCII码表

基本数据类型

关键字





标准 C 库:


Standard C I/O

Standard C String & Character

Standard C Math

Standard C Time & Date

Standard C Memory

Other standard C functions





C++





C++ I/O

C++ Strings





C++ 标准模板库


C++ Bitsets

C++ Double-Ended Queues

C++ Lists

C++ Maps

C++ Multimaps

C++ Multisets

C++ Priority Queues

C++ Queues

C++ Sets

C++ Stacks

C++ Vectors

Iterators





全部的 C 函数 全部的 C++ 函数





有任何问题请联系 整理者

	最后整理于 2/26/2006, 感谢 翻译者.





cppreference.com -> 预处理命令





预处理命令




#, ## manupilate字符串

#define 定义变量

#error 显示一个错误消息

#if, #ifdef, #ifndef, #else, #elif, #endif 条件操作符

#include 插入其它文件的内容

#line 设置行和文件信息

#pragma 执行特殊命令

#undef 取消定义变量

预定义变量 其它变量





cppreference.com -> 预处理命令 -> 详细说明





预处理命令




* * *





#,##


# 和 ## 操作符是和#define宏使用的. 使用# 使在#后的首个参数返回为一个带引号的字符串. 例如, 命令

#define to_string( s ) # s

将会使编译器把以下命令

cout << to_string( Hello World! ) << endl;

理解为

cout << "Hello World!" << endl;

使用##连结##前后的内容. 例如, 命令

#define concatenate( x, y ) x ## y ... int xy = 10; ...

将会使编译器把

cout << concatenate( x, y ) << endl;

解释为

cout << xy << endl;

理所当然,将会在标准输出处显示'10'.



* * *





#define


语法: #define macro-name replacement-string



#define命令用于把指定的字符串替换文件中的宏名称 . 也就是说, #define使编译器把文件中每一个macro-name替换为replacement-string. 替换的字符串结束于行末. 这里是一个经典的#define应用 (至少是在C中): #define TRUE 1 #define FALSE 0 ... int done = 0; while( done != TRUE ) { ... }

#define命令的另外一个功能就是替换参数,使它 假冒创建函数一样使用. 如下的代码:

#define absolute_value( x ) ( ((x) < 0) ? -(x) : (x) ) ... int x = -1; while( absolute_value( x ) ) { ... }

当使用复杂的宏时,最好使用额外的圆括号. 注意在以上的例子中, 变量"x"总是出现在它自己的括号中. 这样, 它就可以在和0比较,或变成负值(乘以-1)前计算值. 同样的, 整个宏也被括号围绕, 以防止和其它代码混淆. 如果你不注意的话, 你可能会被编译器曲解你的代码.



* * *





#error


语法: #error message



#error命令可以简单的使编译器在发生错误时停止. 当遇到一个#error时,编译器会自动输出行号而无论message的内容. 本命令大多是用于调试.



* * *





#if, #ifdef, #ifndef, #else, #elif, #endif


这些命令让编译器进行简单的逻辑控制. 当一个文件被编译时, 你可以使用这些命令使某些行保留或者是去处.

#if expression

如果表达式(expression)的值是"真"(true),那么紧随该命令的代码将会被编译.

#ifdef macro

如果"macro"已经在一个#define声明中定义了, 那么紧随该命令的代码将会被编译.

#ifndef macro

如果"macro"未在一个#define声明中定义, 那么紧随命令的代码将会被编译.

一些小边注: 命令#elif是"elseif"的一种缩写,并且他可以想你所意愿的一样工作. 你也可以在一个#if后插入一个"defined"或者"!defined"以获得更多的功能.

这里是一部分例子:

#ifdef DEBUG cout << "This is the test version, i=" << i << endl; #else cout << "This is the production version!" << endl; #endif

你应该注意到第二个例子比在你的代码中插入多个"cout"进行调试的方法更简单.



* * *





#include


语法: #include <filename> #include "filename"



本命令包含一个文件并在当前位置插入. 两种语法的主要不同之处是在于,如果filename括在尖括号中,那么编译器不知道如何搜索它. 如果它括在引号中, 那么编译器可以简单的搜索到文件. 两种搜索的方式是由编译器决定的,一般尖括号意味着在标准库目录中搜索, 引号就表示在当前目录中搜索. The spiffy new 整洁的新C++ #include目录不需要直接映射到filenames, 至少对于标准库是这样. 这就是你有时能够成功编译以下命令的原因

#include <iostream>



* * *





#line


语法: #line line_number "filename"



#line命令是用于更改__LINE__ 和 __FILE__变量的值. 文件名是可选的. __LINE__ 和 __FILE__ 变量描述被读取的当前文件和行. 命令

#line 10 "main.cpp"

更改行号为10,当前文件改为"main.cpp".



* * *





#pragma


#pragma命令可以让编程者让编译器执行某些事. 因为#pragma命令的执行很特殊,不同的编译器使用有所不同. 一个选项可以跟踪程序的执行.



* * *





#undef


#undef命令取消一个先前已定义的宏变量, 譬如一个用#define定义的变量.



* * *





预定义变量


语法: __LINE__ __FILE__ __DATE__ __TIME__ _cplusplus __STDC__



下列参数在不同的编译器可能会有所不同, 但是一般是可用的:

__LINE__ 和 __FILE__ 变量表示正在处理的当前行和当前文件.

__DATE__ 变量表示当前日期,格式为month/day/year(月/日/年).

__TIME__ 变量描述当前的时间,格式为hour:minute:second(时:分:秒).

_cplusplus 变量只在编译一个C++程序时定义.

__STDC__ 变量在编译一个C程序时定义,编译C++时也有可能定义.





cppreference.com -> C++ 操作符优先级





C++ 操作符优先级





优先级

	操作符



1 () [] -> .

::

! ~ ++ --

2 - (unary) * (dereference)

& (address of) sizeof

3 ->* .*

4 * (multiply) / %

5 + -

6 << >>

7 < <= > >=

8 == !=

9 & (bitwise AND)

10 ^

11 |

12 &&

13 ||

14 ? :

15 = += -= etc.

16 ,





printf( "This\nis\na\ntest\n\nShe said, \"How are you?\"\n" );

This

is

a

test



She said, "How are you?"





cppreference.com -> ASCII 码表





ASCII 码表


下面的 ASCII 码表包含数值在0-127之间的字符的十进制、八进制以及十六进制表示.





十进制八进制十六进制字符 描述

0 0 00 NUL

1 1 01 SOH start of header

2 2 02 STX start of text

3 3 03 ETX end of text

4 4 04 EOT end of transmission

5 5 05 ENQ enquiry

6 6 06 ACK acknowledge

7 7 07 BEL bell

8 10 08 BS backspace

9 11 09 HT horizontal tab

10 12 0A LF line feed

11 13 0B VT vertical tab

12 14 0C FF form feed

13 15 0D CR carriage return

14 16 0E SO shift out

15 17 0F SI shift in

16 20 10 DLE data link escape

17 21 11 DC1 no assignment, but usually XON

18 22 12 DC2

19 23 13 DC3 no assignment, but usually XOFF

20 24 14 DC4

21 25 15 NAK negative acknowledge

22 26 16 SYN synchronous idle

23 27 17 ETB end of transmission block

24 30 18 CAN cancel

25 31 19 EM end of medium

26 32 1A SUB substitute

27 33 1B ESC escape

28 34 1C FS file seperator

29 35 1D GS group seperator

30 36 1E RS record seperator

31 37 1F US unit seperator

32 40 20 SPC space

33 41 21 !

34 42 22 "

35 43 23 #

36 44 24 $

37 45 25 %

38 46 26 &

39 47 27 '

40 50 28 (

41 51 29 )

42 52 2A *

43 53 2B +

44 54 2C ,

45 55 2D -

46 56 2E .

47 57 2F /

48 60 30 0

49 61 31 1

50 62 32 2

51 63 33 3

52 64 34 4

53 65 35 5

54 66 36 6

55 67 37 7

56 70 38 8

57 71 39 9

58 72 3A :

59 73 3B ;

60 74 3C <

61 75 3D =

62 76 3E >

63 77 3F ?

64 100 40 @

65 101 41 A

66 102 42 B

67 103 43 C

68 104 44 D

69 105 45 E

70 106 46 F

71 107 47 G

72 110 48 H

73 111 49 I

74 112 4A J

75 113 4B K

76 114 4C L

77 115 4D M

78 116 4E N

79 117 4F O

80 120 50 P

81 121 51 Q

82 122 52 R

83 123 53 S

84 124 54 T

85 125 55 U

86 126 56 V

87 127 57 W

88 130 58 X

89 131 59 Y

90 132 5A Z

91 133 5B [

92 134 5C \

93 135 5D ]

94 136 5E ^

95 137 5F _

96 140 60 `

97 141 61 a

98 142 62 b

99 143 63 c

100 144 64 d

101 145 65 e

102 146 66 f

103 147 67 g

104 150 68 h

105 151 69 i

106 152 6A j

107 153 6B k

108 154 6C l

109 155 6D m

110 156 6E n

111 157 6F o

112 160 70 p

113 161 71 q

114 162 72 r

115 163 73 s

116 164 74 t

117 165 75 u

118 166 76 v

119 167 77 w

120 170 78 x

121 171 79 y

122 172 7A z

123 173 7B {

124 174 7C |

125 175 7D }

126 176 7E ~

127 177 7F DEL delete





cppreference.com -> C/C++ 数据类型





C/C++ 数据类型


C语言包含5个基本数据类型: void, integer,

float, double, 和 char.

类型描述

void 空类型

int 整型

float 浮点类型

double 双精度浮点类型

char 字符类型



C++ 定义了另外两个基本数据类型: bool 和 wchar_t.

类型描述

bool 布尔类型, 值为true 或 false

wchar_t 宽字符类型





类型修饰符


一些基本数据类型能够被 signed, unsigned,

short, 和 long 修饰. 当类型修饰符单独使用的时候, 默认的类型是 int.

下表是所有可能出现的数据类型:





bool

char

unsigned char

signed char

int

unsigned int

signed int

short int

unsigned short int

signed short int

long int

signed long int

unsigned long int

float

double

long double

wchar_t





类型大小和表示范围


基本数据类型的大小以及能够表示的数据范围是与编译器和硬件平台有关的. "cfloat" (或者 "float.h")

头文件往往定义了基本数据类型能够表示的数据的最大值和最小值. 你也可以使用 sizeof

来获得类型的大小(字节数) .



然而, 很多平台使用了一些数据类型的标准大小，如. int 和 float 通常占用

32位, char 占用 8位,

double 通常占用64位. bools 通常以 8位 来实现.





cppreference.com -> C/C++ Keywords





C/C++ Keywords




asm 插入一个汇编指令.

auto 声明一个本地变量.

bool 声明一个布尔型变量.

break 结束一个循环.

case 一个switch语句的一部分.

catch 处理 thrown 产生的异常.

char 声明一个字符型变量.

class 声明一个类.

const 声明一个常量.

const_cast 从一个const变量中抛出.

continue 在循环中间断循环.

default 是一个case语句中的缺省项.

delete 释放内存.

do 构造循环体.

double 声明一个双精度浮点变量.

dynamic_cast 动态投射.

else 是一个if语句中的预备条件.

enum 创建列举类型.

explicit 仅用在构造器的正确匹配.

extern 告诉编译器在别的地方变量已经被定义过了.

false 属于布尔值.

float 声明一个浮点型变量.

for 构造循环.

friend 允许非函数成员使用私有数据.

goto 跳转到程序的其它地方.

if 从一次判断的结果处执行代码.

inline 定义一个函数为内联.

int 声明一个整型变量.

long 声明一个长整型变量.

mutable 忽略const变量.

namespace 用一个定义的范围划分命名空间.

new 允许动态存储一个新变量.

operator 创建重载函数.

private 在一个类中声明私有成员.

protected 在一个类中声明被保护成员.

public 在一个类中声明公共成员.

register 定义一个寄存器变量.

reinterpret_cast 改变一个变量的类型.

return 从一个函数中返回.

short 声明一个短整型变量.

signed 修改变量类型声明.

sizeof 返回一个变量或类型的长度.

static 给一个变量创建永久的存储空间.

static_cast 执行一个非多态性cast.

struct 创建一个新结构体.

switch 让一个变量在不同的判断下执行不同的代码.

template 创建一个给特殊函数.

this 指向当前对象.

throw 抛出一个异常.

true 布尔类型的一个值.

try 执行一个被throw 抛出的异常.

typedef 从现有的类型中创建一个新类型.

typeid 描述一个对象.

typename 声明一个类或未定义的类型.

union 一个结构体在当前位置分配给多个变量相同的内存.

unsigned 声明一个无符号整型变量.

using 用来输入一个namespace.

virtual 创建一个不被已构成类有限考虑的函数.

void 声明函数或数据是无关联数据类型.

volatile 警告编译器有关的变量可能被出乎意料的修改.

wchar_t 声明一个带有宽度的字符型变量.

while 用来构成循环.





asm( "instruction" );

asm {

instruction-sequence }

asm( instruction );

bool done = false;

while( !done ) {

...

}

while( x < 100 ) {

if( x < 0 ) break; cout << x << endl; x++;

}

class class-name : inheritance-list {



private-members-list;

protected: protected-members-list;

public: public-members-list;

} object-list;

class Date {

int Day; int Month; int Year; public: void display(); };

const_cast<type> (object);

for( int i = 0; i < 21; i++ ) {

if( i == 10 ) {

continue; }

cout << i << " "; }

delete p;

delete[] pArray;

do {

statement-list; } while( condition );

dynamic_cast<type> (object);

enum name {name-list} var-list;

enum color {red, orange, yellow, green, blue, indigo, violet};

color c1 = indigo; if( c1 == indigo ) {

cout << "c1 is indigo" << endl; }

for( initialization; test-condition; increment ) {

statement-list; }

for( int i = 0; i < 10; i++ ) {

cout << "i is " << i << endl; }



int j, k; for( j = 0, k = 10; j < k; j++, k-- ) {

cout << "j is " << j << " and k is " << k << endl; }



for( ; ; ) {

// loop forever!

}

goto labelA;



...



labelA:

if( conditionA ) {

statement-listA; }



else if( conditionB ) {

statement-listB; }



...



else {

statement-listN; }

inline int functionA( int i ) {

...

}

namespace name {

declaration-list; }

namespace CartoonNameSpace {

int HomersAge; void incrementHomersAge() {

HomersAge++; }

}



int main() {

...

CartoonNameSpace::HomersAge = 39; CartoonNameSpace::incrementHomersAge(); cout << CartoonNameSpace::HomersAge << endl; ...

}

pointer = new type;

pointer = new type( initializer ); pointer = new type[size];

return-type class-name::operator#(parameter-list) {

...

}

return-type operator#(parameter-list) {

...

}

reinterpret_cast<type> (object);

return;

return( value );

static_cast<type> (object);

struct struct-name : inheritance-list {



public-members-list;

protected: protected-members-list;

private: private-members-list;

} object-list;

struct Date {

int Day; int Month; int Year; };

switch( expression ) {

case A: statement list; break; case B: statement list; break; ...

case N: statement list; break; default: statement list; break; }

char keystroke = getch();

switch( keystroke ) {

case 'a': case 'b': case 'c': case 'd': KeyABCDPressed(); break; case 'e': KeyEPressed(); break; default: UnknownKeyPressed(); break; }

template <class data-type> return-type name( parameter-list ) {

statement-list; }

template<class X> void genericSwap( X &a, X &b ) {

X tmp;

tmp = a; a = b; b = tmp; }



int main(void) {



...



int num1 = 5; int num2 = 21;

cout << "Before, num1 is " << num1 << " and num2 is " << num2 << endl; genericSwap( num1, num2 ); cout << "After, num1 is " << num1 << " and num2 is " << num2 << endl;

char c1 = 'a'; char c2 = 'z';

cout << "Before, c1 is " << c1 << " and c2 is " << c2 << endl; genericSwap( c1, c2 ); cout << "After, c1 is " << c1 << " and c2 is " << c2 << endl;

...



return( 0 ); }

try {

statement list; }



catch( typeA arg ) {

statement list; }



catch( typeB arg ) {

statement list; }



...



catch( typeN arg ) {

statement list; }

try {

cout << "Before throwing exception" << endl; throw 42; cout << "Shouldn't ever see this" << endl; }



catch( int error ) {

cout << "Error: caught exception " << error << endl; }

typedef existing-type new-type;

typeid( object );

union union-name {



public-members-list;

private: private-members-list;

} object-list;

union Data {

int i; char c; };

virtual return-type name( parameter-list ); virtual return-type name( parameter-list ) = 0;

while( condition ) {

statement-list; }

bool done = false;

while( !done ) {



ProcessData();

if( StopLooping() ) {

done = true; }



}

相关主题:

do, for





cppreference.com -> 标准 C I/O





标准 C I/O




clearerr() 清除错误

fclose() 关闭一个文件

feof() 如果到达文件尾(end-of-file)返回"True"(真)

ferror() 检查一个文件错误

fflush() 书写输出缓存的内容

fgetc() 从流获取一个字符

fgetpos() 获取文件位置指针

fgets() 从一个流获取一串字符

fopen() 打开一个文件

fprintf() 打印格式化的输出到一个文件

fputc() 写一个字符到一个文件

fputs() 写一个字符串到一个文件

fread() 从一个文件读取

freopen() 用一个不同的名称打开一个存在的流

fscanf() 从一个文件读取一个格式化的输入

fseek() 在文件中移动到一个指定的位置

fsetpos() 在一个文件中移动到一个指定的位置

ftell() 返回当前文件的位置指针

fwrite() 写入一个文件

getc() 从一个文件读取一个字符

getchar() 从STDIN(标准输入)读取一个字符

gets() 从STDIN(标准输入)读取一个字符串

perror() 显示当前错误的一个字符串版本到STDERR(标准错误输出)

printf() 写格式化的输出到STDOUT(标准输出)

putc() 写一个字符到一个流

putchar() 写一个字符到STDOUT(标准输出)

puts() 写一个字符串到STDOUT(标准输出)

remove() 清除一个文件

rename() 重命名一个文件

rewind() 移动文件位置指针到一个文件的开始处

scanf() 从STDIN(标准输入)读取格式化输入

setbuf() 设置一个指定流的缓冲区

setvbuf() 设置一个指定流的缓冲区和大小

sprintf() 写格式化的输出到缓冲区

sscanf() 从一个缓冲区读取格式化的输入

tmpfile() 返回一个到一个临时文件的指针

tmpnam() 返回一个独特的文件名

ungetc() 把一个字符放回一个流

vprintf, vfprintf, vsprintf 写用参数列表格式化输出





#include <stdio.h>

void clearerr( FILE *stream );

#include <stdio.h>

int fclose( FILE *stream );

#include <stdio.h>

int feof( FILE *stream );

#include <stdio.h>

int ferror( FILE *stream );

#include <stdio.h>

int fflush( FILE *stream );

printf( "Before first call\n" );

fflush( STDOUT );

shady_function();

printf( "Before second call\n" ); fflush( STDOUT );

dangerous_dereference();

#include <stdio.h>

int fgetc( FILE *stream );

#include <stdio.h>

int fgetpos( FILE *stream, fpos_t *position );

#include <stdio.h>

char *fgets( char *str, int num, FILE *stream );

#include <stdio.h>

FILE *fopen( const char *fname, const char *mode );

char ch;

FILE *input = fopen( "stuff", "r" ); ch = getc( input );

#include <stdio.h>

int fprintf( FILE *stream, const char *format, ... );

char name[20] = "Mary";

FILE *out;

out = fopen( "output.txt", "w" ); if( out != NULL )

fprintf( out, "Hello %s\n", name );

#include <stdio.h>

int fputc( int ch, FILE *stream );

#include <stdio.h>

int fputs( const char *str, FILE *stream );

#include <stdio.h>

int fread( void *buffer, size_t size, size_t num, FILE *stream );

#include <stdio.h>

FILE *freopen( const char *fname, const char *mode, FILE *stream );

#include <stdio.h>

int fscanf( FILE *stream, const char *format, ... );

#include <stdio.h>

int fseek( FILE *stream, long offset, int origin );

#include <stdio.h>

int fsetpos( FILE *stream, const fpos_t *position );

#include <stdio.h>

long ftell( FILE *stream );

#include <stdio.h>

int fwrite( const void *buffer, size_t size, size_t count, FILE *stream );

#include <stdio.h>

int getc( FILE *stream );

char ch;

FILE *input = fopen( "stuff", "r" );

ch = getc( input ); while( ch != EOF ) {

printf( "%c", ch ); ch = getc( input ); }

#include <stdio.h>

int getchar( void );

#include <stdio.h>

char *gets( char *str );

#include <stdio.h>

void perror( const char *str );

#include <stdio.h>

int printf( const char *format, ... );

char name[20] = "Bob";

int age = 21;

printf( "Hello %s, you are %d years old\n", name, age );

Hello Bob, you are 21 years old





%12.6f


%-12.4f

#include <stdio.h>

int putc( int ch, FILE *stream );

char ch;

FILE *input;

input = fopen( "temp.cpp", "r" ); ch = getc( input ); while( ch != EOF ) {

printf( "%c", ch ); ch = getc( input ); }

#include <stdio.h>

int putchar( int ch );

putchar( ch );

putc( ch, STDOUT );

#include <stdio.h>

int puts( char *str );

#include <stdio.h>

int remove( const char *fname );

#include <stdio.h>

int rename( const char *oldfname, const char *newfname );

#include <stdio.h>

void rewind( FILE *stream );

#include <stdio.h>

int scanf( const char *format, ... );

#include <stdio.h>

void setbuf( FILE *stream, char *buffer );

#include <stdio.h>

int setvbuf( FILE *stream, char *buffer, int mode, size_t size );

#include <stdio.h>

int sprintf( char *buffer, const char *format, ... );

char string[50];

int file_number = 0;

sprintf( string, "file.%d", file_number ); file_number++;

output_file = fopen( string, "w" );

#include <stdio.h>

int sscanf( const char *buffer, const char *format, ... );

#include <stdio.h>

FILE *tmpfile( void );

#include <stdio.h>

char *tmpnam( char *name );

#include <stdio.h>

int ungetc( int ch, FILE *stream );

#include <stdarg.h>

#include <stdio.h> int vprintf( char *format, va_list arg_ptr ); int vfprintf( FILE *stream, const char *format, va_list arg_ptr ); int vsprintf( char *buffer, char *format, va_list arg_ptr );

void error( char *fmt, ... ) {

va_list args;



va_start( args, fmt ); fprintf( stderr, "Error: " ); vfprintf( stderr, fmt, args ); fprintf( stderr, "\n" ); va_end( args );

exit( 1 );

}





			atof()

将字符串转换成浮点数



atoi()

将字符串转换成整数



atol()

将字符串转换成长整型数



isalnum()

当字母或数字字符时, 返回真值



isalpha()

当字母字符时, 返回真值



iscntrl()

当控制字符时, 返回真值



isdigit()

当数字字符时, 返回真值



isgraph()

当非空格可打印字符时, 返回真值



islower()

当小写字母字符时, 返回真值



isprint()

当可打印字符时, 返回真值



ispunct()

当标点字符时, 返回真值



isspace()

当空格字符时, 返回真值



isupper()

当大写字母字符时, 返回真值



isxdigit()

当十六进制字符时, 返回真值



memchr()

在某一内存范围中查找一特定字符



memcmp()

比较内存内容



memcpy()

拷贝内存内容



memmove()

拷贝内存内容



memset()

将一段内存空间填入某值



strcat()

连接两个字符串



strchr()

查找某字符在字符串中首次出现的位置



strcmp()

比较两个字符串



strcoll()

采用目前区域的字符排列次序来比较字符串



strcpy()

拷贝字符串



strcspn()

在某字符串中匹配指定字符串



strerror()

返回错误码对应的文本信息



strlen()

返回指定字符串的长度



strncat()

连接某一长度的两个字符串



strncmp()

比较某一长度的两个字符串



strncpy()

复制某一长度的一个字符串到另一字符串中



strpbrk()

查找某字符串在另一字符串中首次出现的位置



strrchr()

查找某字符在字符串中末次出现的位置



strspn()

返回子串的长度，子串的字符都出现包含于另一字符串中



strstr()

在一字符串中查找指定的子串首次出现的位置



strtod()

将字符串转换成浮点数



strtok()

查找指定字符之前的子串



strtol()

将字符串转换成长整型数



strtoul()

将字符串转换成无符号长整型数



strxfrm()

转换子串, 可以用于字符串比较



tolower()

将字符转换成小写字符



toupper()

将字符转换成大写字符





cppreference.com -> Standard C String & Character -> 详解





标准c字符和字符串




* * *





atof


语法:



#include <stdlib.h>

double atof( const char *str );



功能:将字符串str转换成一个双精度数值并返回结果。 参数str 必须以有效数字开头,但是允许以“E”或“e”除外的任意非数字字符结尾。例如：

x = atof( "42.0is_the_answer" );

x的值为42.0.

相关主题: atoi() and atol().



* * *





	atoi


语法:



#include <stdlib.h>

int atoi( const char *str );



功能：将字符串str转换成一个整数并返回结果。参数str 以数字开头，当函数从str 中读到非数字字符则结束转换并将结果返回。例如，

i = atoi( "512.035" );

i 的值为 512.

相关主题:

atof() and atol().



* * *





	atol


语法:



#include <stdlib.h>

long atol( const char *str );



功能：将字符串转换成长整型数并返回结果。函数会扫描参数str字符串，跳过前面的空格字符，直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时才结束转换，并将结果返回。例如，

x = atol( "1024.0001" );

x的值为1024L.

相关主题:

atof() and atoi().



* * *





	isalnum


语法:



#include <ctype.h>

int isalnum( int ch );



功能：如果参数是数字或字母字符，函数返回非零值，否则返回零值。

char c;

scanf( "%c", &c );

if( isalnum(c) )

printf( "You entered the alphanumeric character %c\n", c );

相关主题:

isalpha(), iscntrl(), isdigit(), isgraph(), isprint(), ispunct(), and isspace().



* * *





	isalpha


语法:



#include <ctype.h>

int isalpha( int ch );



功能：如果参数是字母字符，函数返回非零值，否则返回零值。

char c;

scanf( "%c", &c );

if( isalpha(c) )

printf( "You entered a letter of the alphabet\n" );

相关主题:

isalnum(), iscntrl(), isdigit(), isgraph(), isprint(), ispunct(), and isspace().



* * *





	iscntrl


语法:



#include <ctype.h>

int iscntrl( int ch );



功能：如果参数是控制字符（0和0x1F之间的字符，或者等于0x7F）函数返回非零值，否则返回零值。

相关主题:

isalnum(), isalpha(), isdigit(), isgraph(), isprint(), ispunct(), and isspace().



* * *





	isdigit


语法:



#include <ctype.h>

int isdigit( int ch );



功能：如果参数是0到9之间的数字字符，函数返回非零值，否则返回零值.

char c;

scanf( "%c", &c );

if( isdigit(c) )

printf( "You entered the digit %c\n", c );

相关主题:

isalnum(), isalpha(), iscntrl(), isgraph(), isprint(), ispunct(), and isspace().



* * *





	isgraph


语法:



#include <ctype.h>

int isgraph( int ch );



功能：如果参数是除空格外的可打印字符（可见的字符），函数返回非零值，否则返回零值。

相关主题:

isalnum(), isalpha(), iscntrl(), isdigit(), isprint(), ispunct(), and isspace().



* * *





	islower


语法:



#include <ctype.h>

int islower( int ch );



功能：如果参数是小写字母字符，函数返回非零值，否则返回零值。

相关主题:

isupper()



* * *





	isprint


语法:



#include <ctype.h>

int isprint( int ch );



功能：如果参数是可打印字符（包括空格），函数返回非零值，否则返回零值。

相关主题:

isalnum(), isalpha(), iscntrl(), isdigit(), isgraph(), ispunct(), and isspace().



* * *





	ispunct


语法:



#include <ctype.h>

int ispunct( int ch );



功能：如果参数是除字母，数字和空格外可打印字符，函数返回非零值，否则返回零值。

相关主题:

isalnum(), isalpha(), iscntrl(), isdigit(), isgraph(), isprint(), and isspace().



* * *





	isspace


语法:



#include <ctype.h>

int isspace( int ch );



功能：如果参数是空格类字符（即：单空格，制表符，垂直制表符，满页符，回车符，新行符），函数返回非零值，否则返回零值。

相关主题:

isalnum(), isalpha(), iscntrl(), isdigit(), isgraph(), and ispunct().



* * *





	isupper


语法:



#include <ctype.h>

int isupper( int ch );



功能：如果参数是大写字母字符，函数返回非零值，否则返回零值。

相关主题:

tolower()



* * *





	isxdigit


语法:



#include <ctype.h>

int isxdigit( int ch );



功能：如果参数是十六进制数字字符（即：A-F, a-f, 0-9），函数返回非零值，否则返回零值。

相关主题:

isalnum(), isalpha(), iscntrl(), isdigit(), isgraph(), ispunct(), and isspace().



* * *





	memchr


语法:



#include <string.h>

void *memchr( const void *buffer, int ch, size_t count );



功能：函数在buffer指向的数组的count个字符的字符串里查找ch 首次出现的位置。返回一个指针，指向ch 在字符串中首次出现的位置, 如果ch 没有在字符串中找到，返回NULL。例如:

char names[] = "Alan Bob Chris X Dave";

if( memchr(names,'X',strlen(names)) == NULL )

printf( "Didn't find an X\n" );

else

printf( "Found an X\n" );

相关主题:

memcpy() and strstr().



* * *





	memcmp


语法:



#include <string.h>

int memcmp( const void *buffer1, const void *buffer2, size_t count );



功能：函数比较buffer1 和 buffer2的前count 个字符。返回值如下:

Value

解释



less than 0

buffer1 is less than buffer2



equal to 0

buffer1 is equal to buffer2



greater than 0

buffer1 is greater than buffer2



相关主题:

memchr(), memcpy(), and strcmp().



* * *





	memcpy


语法:



#include <string.h>

void *memcpy( void *to, const void *from, size_t count );



功能：函数从from中复制count 个字符到to中，并返回to指针。 如果to 和 from 重叠，则函数行为不确定。

相关主题:

memmove().



* * *





	memmove


语法:



#include <string.h>

void *memmove( void *to, const void *from, size_t count );



功能: 与mencpy相同，不同的是当to 和 from 重叠，函数正常仍能工作。

相关主题:

memcpy().



* * *





	memset


语法:



#include <string.h>

void *memset( void *buffer, int ch, size_t count );



功能: 函数拷贝ch 到buffer 从头开始的count 个字符里, 并返回buffer指针。 memset() 可以应用在将一段内存初始化为某个值。例如：

memset( the_array, '\0', sizeof(the_array) );

这是将一个数组的所以分量设置成零的很便捷的方法。

相关主题:

memcmp(), memcpy(), and memmove().



* * *





	strcat


语法:



#include <string.h>

char *strcat( char *str1, const char *str2 );



功能：函数将字符串str2 连接到str1的末端，并返回指针str1. 例如：

printf( "Enter your name: " );

scanf( "%s", name );

title = strcat( name, " the Great" );

printf( "Hello, %s\n", title );

相关主题:

strchr(), strcmp(), and strcpy().



* * *





	strchr


语法:



#include <string.h>

char *strchr( const char *str, int ch );



功能：函数返回一个指向str 中ch 首次出现的位置，当没有在str 中找ch到返回NULL。

相关主题:

strpbrk(), strspn(), strstr(), and strtok().



* * *





	strcmp


语法:



#include <string.h>

int strcmp( const char *str1, const char *str2 );



功能：比较字符串str1 and str2, 返回值如下:

返回值

解释



less than 0

str1 is less than str2



equal to 0

str1 is equal to str2



greater than 0

str1 is greater than str2



例如: printf( "Enter your name: " );

scanf( "%s", name );

if( strcmp( name, "Mary" ) == 0 )

printf( "Hello, Dr. Mary!\n" );

相关主题:

memcmp(), strchr(), strcpy(), and strncmp().



* * *





	strcoll


语法:



#include <string.h>

int strcoll( const char *str1, const char *str2 );



功能：比较字符串str1 和 str2, 很象strcmp. 但是, strcoll() 使用在目前环境中由setlocale()设定的次序进行比较。



* * *





	strcpy


语法:



#include <string.h>

char *strcpy( char *to, const char *from );



功能：复制字符串from 中的字符到字符串to，包括空值结束符。返回值为指针to。

相关主题:

memcpy(), strchr(), strcmp(), strncmp(), and strncpy().



* * *





	strcspn


语法:



#include <string.h>

size_t strcspn( const char *str1, const char *str2 );



功能：函数返回str1 开头连续n个字符都不含字符串str2内字符的字符数。

相关主题:

strrchr(), strpbrk(), strstr(), and strtok().



* * *





	strerror


语法:



#include <string.h>

char *strerror( int num );



功能：函数返回一个被定义的与某错误代码相关的错误信息。



* * *





	strlen


语法:



#include <string.h>

size_t strlen( char *str );



功能：函数返回字符串str 的长度( 即空值结束符之前字符数目)。

相关主题:

memcpy(), strchr(), strcmp(), and strncmp().



* * *





	strncat


语法:



#include <string.h>

char *strncat( char *str1, const char *str2, size_t count );



功能：将字符串from 中至多count个字符连接到字符串to中，追加空值结束符。返回处理完成的字符串。

相关主题:

strcat(), strnchr(), strncmp(), and strncpy().



* * *





	strncmp


语法:



#include <string.h>

int strncmp( const char *str1, const char *str2, size_t count );



功能：比较字符串str1 和 str2中至多count个字符。返回值如下：

返回值

解释



less than 0

str1 is less than str2



equal to 0

str1 is equal to str2



greater than 0

str1 is greater than str2



如果参数中任一字符串长度小于count, 那么当比较到第一个空值结束符时，就结束处理。

相关主题:

strcmp(), strnchr(), and strncpy().



* * *





	strncpy


语法:



#include <string.h>

char *strncpy( char *to, const char *from, size_t count );



功能：将字符串from 中至多count个字符复制到字符串to中。如果字符串from 的长度小于count，其余部分用'\0'填补。返回处理完成的字符串。

相关主题:

memcpy(), strchr(), strncat(), and strncmp().



* * *





	strpbrk


语法:



#include <string.h>

char *strpbrk( const char *str1, const char *str2 );



功能：函数返回一个指针，它指向字符串str2中任意字符在字符串str1 首次出现的位置，如果不存在返回NULL。

相关主题:

strspn(), strrchr(), strstr(), and strtok().



* * *





	strrchr


语法:



#include <string.h>

char *strrchr( const char *str, int ch );



功能：函数返回一个指针，它指向字符ch 在字符串str末次出现的位置，如果匹配失败，返回NULL。

相关主题:

strpbrk(), strspn(), strstr(), strtok(),



* * *





	strspn


语法:



#include <string.h>

size_t strspn( const char *str1, const char *str2 );



功能：函数返回字符串str1中第一个不包含于字符串str2的字符的索引。

相关主题:

strpbrk(), strrchr(), strstr(), strtok(),



* * *





	strstr


语法:



#include <string.h>

char *strstr( const char *str1, const char *str2 );



功能：函数返回一个指针，它指向字符串str2 首次出现于字符串str1中的位置，如果没有找到，返回NULL。

相关主题:

strchr(), strcspn(), strpbrk(), strspn(), strtok(), strrchr(),



* * *





	strtod


语法:



#include <stdlib.h>

double strtod( const char *start, char **end );



功能：函数返回带符号的字符串start所表示的浮点型数。字符串end 指向所表示的浮点型数之后的部分。如果溢出发生，返回HUGE_VAL或 -HUGE_VAL。

相关主题:

atof()



* * *





	strtok


语法:



#include <string.h>

char *strtok( char *str1, const char *str2 );



功能：函数返回字符串str1中紧接“标记”的部分的指针, 字符串str2是作为标记的分隔符。如果分隔标记没有找到，函数返回NULL。为了将字符串转换成标记，第一次调用str1 指向作为标记的分隔符。之后所以的调用str1 都应为NULL。

例如: char str[] = "now # is the time for all # good men to come to the # aid of their country";

char delims[] = "#";

char *result = NULL;



result = strtok( str, delims );



while( result != NULL ) {

printf( "result is \"%s\"\n", result );

result = strtok( NULL, delims );

}

以上代码的运行结果是：

result is "now "

result is " is the time for all "

result is " good men to come to the "

result is " aid of their country"

相关主题:

strchr(), strcspn(), strpbrk(), strrchr(), and strspn().



* * *





	strtol


语法:



#include <stdlib.h>

long strtol( const char *start, char **end, int base );



功能：函数返回带符号的字符串start所表示的长整型数。参数base代表采用的进制方式。指针end 指向start所表示的整型数之后的部分。如果返回值无法用长整型表示，函数则返回LONG_MAX或LONG_MIN. 错误发生时，返回零。

相关主题:

atol().



* * *





	strtoul


语法:



#include <stdlib.h>

unsigned long strtoul( const char *start, char **end, int base );



功能：函数基本等同 strtol(), 不同的是，它不仅可以返回长整型数，而且可以返回无符号的长整型数。

相关主题:

strtol()



* * *





	strxfrm


语法:



#include <string.h>

size_t strxfrm( char *str1, const char *str2, size_t num );



功能：函数将字符串str2 的前num 个字符存储到字符串str1中。如果strcoll() 处理字符串str1 和旧的字符串str2, 返回值和strcmp()的处理结果一样。

相关主题:

strcmp(), strcoll(),



* * *





	tolower


语法:



#include <ctype.h>

int tolower( int ch );



功能：函数字符ch的小写形式。

相关主题:

toupper(),



* * *





	toupper


语法:



#include <ctype.h>

int toupper( int ch );



功能：函数字符ch的大写形式。

相关主题:

tolower(),





cppreference.com -> 	标准c数学函数





Standard C Math


abs()

	求绝对值



acos()

	求反余弦



asin()

	求反正弦



atan()

	求反正切



atan2()

	求反正切，按符号判定象限



ceil()

	求不小于某值的最小整数 	（求上界）



cos()

	求余弦



cosh()

	求双曲余弦



div()

	求商和余数



exp()

	求e的幂



fabs()

	求浮点数的绝对值



floor()

	求不大于某值的最大整数 	（求下界）



fmod()

	求模数



frexp()

	求数的科学表示法形式



labs()

	求长整型数的绝对值



ldexp()

	以科学计数法计算



ldiv()

	以长整型返回商和余数



log()

	自然对数



log10()

	以10为底的自然对数



modf()

	将一个数分解成整数和小数部分



pow()

	求幂



sin()

	求正弦



sinh()

	求双曲正弦



sqrt()

	求平方根



tan()

	求正切



tanh()

	求双曲正切





cppreference.com -> 标准c数学函数 -> 详解





标准c数学函数




* * *





abs


语法:



#include <stdlib.h>

int abs( int num );



功能： 函数返回参数num.的绝对值。例如: int magic_number = 10;

cout << "Enter a guess: ";

cin >> x;

cout << "Your guess was " << abs( magic_number - x ) << " away from the magic number." << endl;

相关主题: labs().



* * *





acos


语法:



#include <math.h>

double acos( double arg );



功能： 函数返回参数arg的反余弦值。参数arg 应当在-1和1之间。

相关主题:

asin(), atan(), atan2(), sin(), cos(), tan(), sinh(), cosh(), and tanh().



* * *





asin


语法:



#include <math.h>

double asin( double arg );



功能： 函数返回参数arg的反正弦值。参数arg 应当在-1和1之间。

相关主题:

acos(), atan(), atan2(), sin(), cos(), tan(), sinh(), cosh(), and tanh().



* * *





atan


语法:



#include <math.h>

double atan( double arg );



功能： 函数返回参数arg的反正切值。

相关主题:

asin(), acos(), atan2(), sin(), cos(), tan(), sinh(), cosh(), and tanh().



* * *





atan2


语法:



#include <math.h>

double atan2( double y, double x );



功能： 函数计算y/x的反正切值，按照参数的符号计算所在的象限。

相关主题:

asin(), acos(), atan(), sin(), cos(), tan(), sinh(), cosh(), and tanh().



* * *





ceil


语法:



#include <math.h>

double ceil( double num );



功能： 函数返回参数不小于num 的最小整数。例如, y = 6.04;

x = ceil( y );

x为7.0.

相关主题:

floor() and fmod().



* * *





cos


语法:



#include <math.h>

double cos( double arg );



功能： 函数返回参数arg的余弦值，arg以弧度表示给出。

相关主题:

asin(), acos(), atan(), sin(), atan2(), tan(), sinh(), cosh(), and tanh().



* * *





cosh


语法:



#include <math.h>

double cosh( double arg );



功能： 函数返回参数arg的双曲余弦值。

相关主题:

asin(), acos(), atan(), sin(), atan2(), tan(), sinh(), cos(), and tanh().



* * *





div


语法:



#include <stdlib.h>

div_t div( int numerator, int denominator );



功能： 函数返回参数numerator / denominator的商和余数。结构类型div_t定义在stdlib.h中: int quot; // 商数

int rem; // 余数

例, 以下代码显示x/y的商和余数: div_t temp;

temp = div( x, y );

printf( "%d divided by %d yields %d with a remainder of %d\n", x, y, temp.quot, temp.rem );

相关主题:

ldiv().



* * *





exp


语法:



#include <math.h>

double exp( double arg );



功能： 函数返回参数returns e (2.7182818) 的arg次幂。

相关主题:

log().



* * *





fabs


语法:



#include <math.h>

double fabs( double arg );



功能： 函数返回参数arg的绝对值。

相关主题:

abs().



* * *





floor


语法:



#include <math.h>

double floor( double arg );



功能： 函数返回参数不大于arg的最大整数。例如, y = 6.04;

x = floor( y );

x的值为6.0.

相关主题:

ceil().



* * *





fmod


语法:



#include <math.h>

double fmod( double x, double y );



功能： 函数返回参数x/y的余数。

相关主题:

ceil(), floor(), and fabs().



* * *





frexp


语法:



#include <math.h>

double frexp( double num, int *exp );



功能： 函数将参数num 分成两部分： 0.5 和1之间的尾数（由函数返回）并返回指数exp。转换成如下的科学计数法形式：

num = mantissa * (2 ^ exp)

相关主题:

ldexp().



* * *





labs


语法:



#include <stdlib.h>

long labs( long num );



功能： 函数返回参数num的绝对值。

相关主题:

abs().



* * *





ldexp


语法:



#include <math.h>

double ldexp( double num, int exp );



功能： 函数返回参数num * (2 ^ exp)。如果发生溢出返回HUGE_VAL。

相关主题:

frexp() and modf().



* * *





ldiv


语法:



#include <stdlib.h>

ldiv_t ldiv( long numerator, long denominator );



功能： 函数返回参数numerator / denominator的商和余数。结构类型 ldiv_t 定义在stdlib.h中：

long quot; // 商数

long rem; // 余数

相关主题:

div().



* * *





log


语法:



#include <math.h>

double log( double num );



功能： 函数返回参数num的自然对数。如果num为负,产生域错误；如果num 为零，产生范围错误。

相关主题:

log10().



* * *





log10


语法:



#include <math.h>

double log10( double num );



功能： 函数返回参数num以10为底的对数。如果num为负,产生域错误；如果num 为零，产生范围错误。

相关主题:

log().



* * *





modf


语法:



#include <math.h>

double modf( double num, double *i );



功能： 函数将参数num 分割为整数和小数，返回小数部分并将整数部分赋给i。

相关主题:

frexp() and ldexp().



* * *





pow


语法:



#include <math.h>

double pow( double base, double exp );



功能： 函数返回以参数base 为底的exp 次幂。如果base为零或负和exp 小于等于零或非整数时,产生域错误。如果溢出，产生范围错误。

相关主题:

exp(), log(), and sqrt().



* * *





sin


语法:



#include <math.h>

double sin( double arg );



功能： 函数返回参数arg的正弦值，arg以弧度表示给出。

相关主题:

asin(), acos(), atan(), cosh(), atan2(), tan(), sinh(), cos(), and tanh().



* * *





sinh


语法:



#include <math.h>

double sinh( double arg );



功能： 函数返回参数arg的双曲正弦值。

相关主题:

asin(), acos(), atan(), cosh(), atan2(), tan(), sin(), cos(), and tanh().



* * *





sqrt


语法:



#include <math.h>

double sqrt( double num );



功能： 函数返回参数num的平方根。如果num为负,产生域错误。

相关主题:

exp(), log(), and pow().



* * *





tan


语法:



#include <math.h>

double tan( double arg );



功能： 函数返回参数arg的正切值，arg以弧度表示给出。

相关主题:

asin(), acos(), atan(), cosh(), atan2(), sinh(), sin(), cos(), and tanh().



* * *





tanh


语法:



#include <math.h>

double tanh( double arg );



功能： 函数返回参数arg的双曲正切值。

相关主题:

asin(), acos(), atan(), cosh(), atan2(), tan(), sin(), cos(), and sinh().





cppreference.com -> 标准c时间与日期函数





标准c时间与日期函数




asctime()





时间文本格式





clock()





返回自程序开始运行所经过的时间





ctime()





返回特定格式时间





difftime()





两时刻的间隔





gmtime()





返回指向当前格林威治时间的指针





localtime()





返回指向当前时间的指针





mktime()





返回指定时间的日历格式





strftime()





返回日期和时间的单个元素





time()





返回系统的当前日历时间





cppreference.com -> 标准c时间与日期函数 -> 详解





标准c时间与日期函数




* * *





asctime


语法:



#include <time.h>

char *asctime( const struct tm *ptr );



功能： 函数将ptr所指向的时间结构转换成下列字符串：

day month date hours:minutes:seconds year\n\0

例如:

Mon Jun 26 12:03:53 2000

相关主题: localtime(), gmtime(), time(), and ctime().



* * *





clock


语法:



#include <time.h>

clock_t clock( void );



功能： 函数返回自程序开始运行的处理器时间，如果无可用信息，返回-1。 转换返回值以秒记, 返回值除以CLOCKS_PER_SECOND. (注: 如果编译器是POSIX兼容的, CLOCKS_PER_SECOND定义为1000000.)

相关主题:

time(), asctime(), and ctime().



* * *





ctime


语法:



#include <time.h>

char *ctime( const time_t *time );



功能： 函数转换参数time为本地时间格式：

day month date hours:minutes:seconds year\n\0

ctime() 等同

asctime( localtime( tp ) );

相关主题:

localtime(), gmtime(), time(), and asctime().



* * *





difftime


语法:



#include <time.h>

double difftime( time_t time2, time_t time1 );



功能： 函数返回时间参数time2和time1之差的秒数表示。

相关主题:

localtime(), gmtime(), time(), and asctime().



* * *





gmtime


语法:



#include <time.h>

struct tm *gmtime( const time_t *time );



功能： 函数返回给定的统一世界时间（通常是格林威治时间），如果系统不支持统一世界时间系统返回NULL。 警告!

相关主题:

localtime(), time(), and asctime().



* * *





localtime


语法:



#include <time.h>

struct tm *localtime( const time_t *time );



功能： 函数返回本地日历时间。警告！

相关主题:

gmtime(), time(), and asctime().



* * *





mktime


语法:



#include <time.h>

time_t mktime( struct tm *time );



功能： 函数转换参数time 类型的本地时间至日历时间，并返回结果。如果发生错误，返回－1。

相关主题:

time(), gmtime(), asctime(), and ctime().



* * *





strftime


语法:



#include <time.h>

size_t strftime( char *str, size_t maxsize, const char *fmt, struct tm *time );



功能： 函数按照参数fmt所设定格式将time类型的参数格式化为日期时间信息，然后存储在字符串str中（至多maxsize 个字符）。用于设定时间不同类型的代码为：

代码

含义



%a

星期的缩略形式



%A

星期的完整形式



%b

月份的缩略形式



%B

月份的完整形式



%c

月份的缩略形式



%d

月中的第几天(1-31)



%H

小时, 24小时格式 (0-23)



%I

小时, 12小时格式 (1-12)



%j

年中的第几天(1-366)



%m

月份 (1-12). Note: 某些版本的Microsoft Visual C++ 可能使用取值范围0-11.



%M

分钟(0-59)



%p

本地时间的上午或下午（AM or PM）



%S

秒钟(0-59)



%U

年中的第几周，星期天是一周的第一天



%w

星期几的数字表示(0-6, 星期天=0)



%W

一年中的第几周，星期天是一周的第一天



%x

标准日期字符串



%X

标准时间字符串



%y

年(0-99)



%Y

用CCYY表示的年（如：2004）



%Z

时区名



%%

百分号



函数strftime()返回值为处理结果字符串str中字符的个数，如果发生错误返回零。

相关主题:

time(), localtime(), and gmtime().



* * *





time


语法:



#include <time.h>

time_t time( time_t *time );



功能： 函数返回当前时间，如果发生错误返回零。如果给定参数time ，那么当前时间存储到参数time中。

相关主题:

localtime(), gmtime(), strftime(), ctime(),





cppreference.com -> 标准c内存函数





标准c内存函数




calloc()





分配一个二维储存空间





free()





释放已分配空间





malloc()





分配空间





realloc()





改变已分配空间的大小





<span lang="EN-US"><!--[if !supportEmptyParas]--> <!--[endif]--><o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>#include <stdlib.h><o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>void *calloc( size_t num, size_t size );<o:p></o:p></span>

<span lang="EN-US"><!--[if !supportEmptyParas]--> <!--[endif]--><o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>#include <stdlib.h><o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>void free( void *ptr );<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>typedef struct data_type {<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>int age;<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>char name[20];<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>} data;<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span><o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>data *willy;<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>willy = (data*) malloc( sizeof(willy) );<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>...<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>free( willy );<o:p></o:p></span>

<span lang="EN-US"><!--[if !supportEmptyParas]--> <!--[endif]--><o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>#include <stdlib.h><o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>void *malloc( size_t size );<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>typedef struct data_type {<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>int age;<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>char name[20];<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>} data;<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span><o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>data *bob;<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>bob = (data*) malloc( sizeof(data) );<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>if( bob != NULL ) {<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>bob->age = 22;<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>strcpy( bob->name, "Robert" );<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>printf( "%s is %d years old\n", bob->name, bob->age );<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>}<o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>free( bob );<o:p></o:p></span>

<span lang="EN-US"><!--[if !supportEmptyParas]--> <!--[endif]--><o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>#include <stdlib.h><o:p></o:p></span>

<span lang="EN-US"><span style="mso-spacerun: yes"> </span>void *realloc( void *ptr, size_t size );<o:p></o:p></span>

功能： 函数将ptr 对象的储存空间改变为给定的大小size。 参数size可以是任意大小，大于或小于原尺寸都可以。 返回值是指向新空间的指针，如果错误发生返回NULL。

相关主题:

free(), malloc(), and calloc().





cppreference.com -> 其他标准c函数





其他标准c函数


abort()

停止程序执行



assert()

当表达式非真，停止程序执行



atexit()

当程序退出执行设定的程序



bsearch()

执行折半查找



exit()

停止程序执行



getenv()

获取指定环境变量的值



longjmp()

从设定点执行程序



qsort()

执行快速排序



raise()

向程序发送信号



rand()

返回一个随机数



setjmp()

设置程序执行点



signal()

将某函数设置成一个信号句柄



srand()

初始化随机数发生源



system()

执行系统调用



va_arg()

使用可变长度参数列表





cppreference.com -> 其他标准c函数 -> Details





其他标准c函数





* * *





abort


语法:





#include <stdlib.h> void abort( void );



功能： 终止程序的执行。返回值依赖于执行，可以通过返回值显示错误。

相关主题: exit() and atexit().





* * *





assert


语法:





#include <assert.h> void assert( int exp );



功能： 宏assert()用于错误检测。如果表达式的结果为零，宏写错误信息到STDERR并退出程序执行。如果宏NDEBUG已经定义，宏assert()将被忽略。

相关主题:

abort()





* * *





atexit


语法:





#include <stdlib.h> int atexit( void (*func)(void) );



功能： 当程序终止执行时，函数调用函数指针func所指向的函数。可以执行多重调用(至少32个)，这些函数以其注册的倒序执行。执行成功返回零值，失败则返回非零值。

相关主题:

exit() and abort().





* * *





bsearch


语法:





#include <stdlib.h> void *bsearch( const void *key, const void *buf, size_t num, size_t size, int (*compare)(const void *, const void *) );



功能： 函数用折半查找法在从数组元素buf[0]到buf[num-1] 匹配参数key。如果函数compare 的第一个参数小于第二个参数，返回负值；如果等于返回零值；如果大于返回正值。数组buf 中的元素应以升序排列。函数bsearch()的返回值是指向匹配项，如果没有发现匹配项，返回NULL。

相关主题:

qsort().





* * *





exit


语法:





#include <stdlib.h> void exit( int exit_code );



功能：终止程序的执行。参数exit_code 传递给返回值，通常零值表示正常结束，非零值表示应错误返回。

相关主题:

atexit() and abort().





* * *





getenv


语法:





#include <stdlib.h> char *getenv( const char *name );



功能： 函数返回环境变量name的值，非常依赖执行情况。如果无对应的环境变量name返回NULL。

相关主题:

system().





* * *





longjmp


语法:





#include <setjmp.h> void longjmp( jmp_buf envbuf, int status );



功能： 函数使程序从前次对setjmp()的调用处继续执行。参数envbuf一般通过调用setjmp()设定。参数status 为setjmp()的返回值，用来指示不同地点longjmp()的执行. status 不能设定为零。

相关主题:

setjmp().





* * *





qsort


语法:





#include <stdlib.h> void qsort( void *buf, size_t num, size_t size, int (*compare)(const void *, const void *) );



功能： 对buf 指向的数据(包含num 项,每项的大小为size)进行快速排序。如果函数compare 的第一个参数小于第二个参数，返回负值；如果等于返回零值；如果大于返回正值。函数对buf 指向的数据按升序排序。

相关主题:

bsearch().





* * *





raise


语法:





#include <signal.h> int raise( int signal );



功能： 函数对程序发送指定的信号signal. 一些信号:

信号





含义





SIGABRT





终止错误





SIGFPE





浮点错误





SIGILL





无效指令





SIGINT





用户输入





SIGSEGV





非法内存存取





SIGTERM





终止程序





返回零值为成功，非零为失败。

相关主题:

signal()





* * *





rand


语法:





#include <stdlib.h> int rand( void );



功能： 函数返回一个在零到RAND_MAX 之间的伪随机整数。例如： srand(

time(NULL) ); for( i = 0; i < 10; i++

) printf( "Random number #%d:

%d\n", i, rand() );

相关主题:

srand()





* * *





setjmp


语法:





#include <setjmp.h> int setjmp( jmp_buf envbuf );



功能： 函数将系统栈保存于envbuf中，以供以后调用longjmp()。当第一次调用setjmp(),它的返回值为零。之后调用longjmp(),longjmp()的第二个参数即为setjmp()的返回值。是否有点疑问？请参阅longjmp().

相关主题:

longjmp()





* * *





signal


语法:





#include <signal.h> void ( *signal( int signal, void (* func) (int)) ) (int);



功能： 当函数收到参数signal所表示的信号，参数func 所指向的函数即被调用。func 可以被定制为信号句柄或以下的宏(定义在signal.h中):

宏





解释





SIG_DFL





默认信号处理





SIG_IGN





忽略信号





signal()返回先前为信号定义的函数地址，当错误发生返回SIG_ERR。





* * *





srand


语法:





#include <stdlib.h> void srand( unsigned seed );



功能： 设置rand()随机序列种子。对于给定的种子seed, rand()会反复产生特定的随机序列。 srand(

time(NULL) ); for( i = 0; i < 10; i++

) printf( "Random number #%d:

%d\n", i, rand() );

相关主题:

rand(), time().





* * *





system


语法:





#include <stdlib.h> int system( const char *command );



功能： 函数返回给定的命令字符串command 进行系统调用。如果命令执行正确通常返回零值。如果command 为 NULL, system()将尝试是否有可用的命令解释器。 如果有返回非零值，否则返回零值。

相关主题:

exit(),





* * *





va_arg


语法:





#include <stdarg.h> type va_arg( va_list argptr, type ); void va_end( va_list argptr ); void va_start( va_list argptr, last_parm );



功能： 宏va_arg()用于给函数传递可变长度的参数列表。



首先，必须调用va_start() 传递有效的参数列表va_list和函数强制的第一个参数。第一个参数代表将要传递的参数的个数。

其次，调用va_arg()传递参数列表va_list 和将被返回的参数的类型。va_arg()的返回值是当前的参数。

再次，对所有的参数重复调用va_arg()

最后，调用va_end()传递va_list对完成后的清除是必须的。



For example:

int sum( int, ... );

int main(

void ) {



int answer = sum( 4, 4, 3, 2, 1 );

printf( "The answer is

%d\n", answer );



return( 0 );

}



int sum( int num, ... ) {

int answer = 0;

va_list argptr;



va_start( argptr, num );

for( ; num > 0; num-- )

answer += va_arg(

argptr, int );



va_end( argptr );

return( answer );

}





这段代码显示10,他们是4+3+2+1。





cppreference.com -> C++ I/O





C++ I/O


<iostream>库自动定义了一些标准对象:





cout, ostream类的一个对象，可以将数据显示在标准输出设备上.





cerr, ostream类的另一个对象，它无缓冲地向标准错误输出设备输出数据.





clog, 类似cerr,但是它使用缓冲输出.





cin, istream类的一个对象,它用于从标准输入设备读取数据.





<fstream>库允许编程人员利用ifstream和ofstream类进行文件输入和输出.

一些C++ I/O流(精度，判断等)的行为可以通过操作不同的标志来修改。





Constructors 构造器

bad() 如果出现错误则返回true

clear() 清除状态标志

close() 关闭一个流

eof() 如果处于文件结尾处则返回true

fail() 如果出现错误则返回true

fill() 控制默认填充字符

flags() 操作flags

flush() 清空缓冲区

gcount() 返回读取的最后一次输入的字符数

get() 读取字符

getline() 读取一行字符

good() 如果没有出现过错误则返回true

ignore() 读取字符并忽略指定字符

open() 创建一个输入流

peek() 检查下一个输入的字符

precision() 设置精度

put() 写字符

putback() 返回字符给一个流

rdstate() 返回流的状态

read() 读取字条符

seekg() 在一个输入流中进行随机访问

seekp() 在一个输出流中进行随机访问

setf() 设置格式标志

sync_with_stdio() 同标准I/O同步

tellg() 使用输入流读取流指针

tellp() 使用输出流读取流指针

unsetf() 清除格式标志

width() 操作域宽度

write() 写字符





fstream( const char *filename, openmode mode ); ifstream( const char *filename, openmode mode ); ofstream( const char *filename, openmode mode );

ifstream fin( "/tmp/data.txt" );

ofstream fout( "/tmp/results.txt", ios::app ); while( fin >> temp ) fout << temp + 2 << endl; fin.close(); fout.close();

bool bad();

void clear( iostate flags = goodbit );

void close();

bool eof();

char ch;

ifstream fin( "temp.txt" ); while( !fin.eof() ) {

fin >> ch; cout << ch; }

fin.close();

bool fail();

char fill();

char fill( char ch );

fmtflags flags();

fmtflags flags( fmtflags f );

ostream &flush();

streamsize gcount();

int get();

istream &get( char &ch ); istream &get( char *buffer, streamsize num ); istream &get( char *buffer, streamsize num, char delim ); istream &get( streambuf &buffer ); istream &get( streambuf &buffer, char delim );

char ch;

ifstream fin( "temp.txt" ); while( fin.get(ch) ) cout << ch; fin.close();

istream &getline( char *buffer, streamsize num ); istream &getline( char *buffer, streamsize num, char delim );

bool good();

istream &ignore( streamsize num=1, int delim=EOF );

void open( const char *filename );

void open( const char *filename, openmode mode );

ifstream inputStream("file.txt");

if( !inputStream ) {

cerr << "Error opening input stream" << endl; return;

}

int peek();

streamsize precision();

streamsize precision( streamsize p );

float num = 314.15926535;

cout.precision( 5 ); cout << num;





314.16


ostream &put( char ch );

istream &putback( char ch );

iostate rdstate();

istream &read( char *buffer, streamsize num );

struct {

int height;

int width;

} rectangle;

input_file.read( (char *)(&rectangle), sizeof(rectangle) ); if( input_file.bad() ) {

cerr << "Error reading data" << endl; exit( 0 );

}

istream &seekg( off_type offset, ios::seekdir origin ); istream &seekg( pos_type position );

ostream &seekp( off_type offset, ios::seekdir origin ); ostream &seekp( pos_type position );

fmtflags setf( fmtflags flags );

fmtflags setf( fmtflags flags, fmtflags needed );

int number = 0x3FF;

cout.setf( ios::dec ); cout << "Decimal: " << number << endl; cout.unsetf( ios::dec ); cout.setf( ios::hex ); cout << "Hexadecimal: " << number << endl;

int number = 0x3FF;

cout << "Decimal: " << number << endl << hex << "Hexadecimal: " << number << dec << endl;

static bool sync_with_stdio( bool sync=true );

pos_type tellg();

pos_type tellp();

string s("In Xanadu did Kubla Khan...");

ofstream fout("output.txt");

for( int i=0; i < s.length(); i++ ) {

cout << "File pointer: " << fout.tellp(); fout.put( s[i] ); cout << " " << s[i] << endl; }



fout.close();

void unsetf( fmtflags flags );

int width();

int width( int w );

cout.width( 5 );

cout << "2";

2

ostream &write( const char *buffer, streamsize num );

write()函数用于输出流，从buffer中写num个字节到当前输出流中。

相关主题:

read(), put()





cppreference.com -> C++ Strings





C++ Strings(字符串)




Constructors 构造函数，用于字符串初始化

Operators 操作符，用于字符串比较和赋值

append() 在字符串的末尾添加文本

assign() 为字符串赋新值

at() 按给定索引值返回字符

begin() 返回一个迭代器，指向第一个字符

c_str() 将字符串以C字符数组的形式返回

capacity() 返回重新分配空间前的字符容量

compare() 比较两个字符串

copy() 将内容复制为一个字符数组

data() 返回内容的字符数组形式

empty() 如果字符串为空，返回真

end() 返回一个迭代器，指向字符串的末尾。（最后一个字符的下一个位置）

erase() 删除字符

find() 在字符串中查找字符

find_first_of() 查找第一个与value中的某值相等的字符

find_first_not_of() 查找第一个与value中的所有值都不相等的字符

find_last_of() 查找最后一个与value中的某值相等的字符

find_last_not_of() 查找最后一个与value中的所有值都不相等的字符

get_allocator() 返回配置器

insert() 插入字符

length() 返回字符串的长度

max_size() 返回字符的最大可能个数

rbegin() 返回一个逆向迭代器，指向最后一个字符

rend() 返回一个逆向迭代器，指向第一个元素的前一个位置

replace() 替换字符

reserve() 保留一定容量以容纳字符串（设置capacity值）

resize() 重新设置字符串的大小

rfind() 查找最后一个与value相等的字符（逆向查找）

size() 返回字符串中字符的数量

substr() 返回某个子字符串

swap() 交换两个字符串的内容





string();

string( size_type length, char ch ); string( const char *str ); string( const char *str, size_type length ); string( string &str, size_type index, size_type length ); string( <a href="iterators.html">input_iterator</a> start, <a href="iterators.html">input_iterator</a> end );

string str1( 5, 'c' );

string str2( "Now is the time..." ); string str3( str2, 11, 4 ); cout << str1 << endl; cout << str2 << endl; cout << str3 << endl;

ccccc

Now is the time...

time

==

>

<

>=

<=

!=

+

+=

[]

basic_string &append( const basic_string &str ); basic_string &append( const char *str ); basic_string &append( const basic_string &str, size_type index, size_type len ); basic_string &append( const char *str, size_type num ); basic_string &append( size_type num, char ch ); basic_string &append( <a href="iterators.html">input_iterator</a> start, <a href="iterators.html">input_iterator</a> end );

string str = "Hello World";

str.append( 10, '!' );

cout << str << endl;

Hello World!!!!!!!!!!

basic_string &assign( const basic_string &str ); basic_string &assign( const char *str ); basic_string &assign( const char *str, size_type num ); basic_string &assign( const basic_string &str, size_type index, size_type len ); basic_string &assign( size_type num, char ch );

string str1, str2 = "War and Peace";

str1.assign( str2, 4, 3 ); cout << str1 << endl;

and

reference at( size_type index );

string text = "ABCDEF";

char ch = text.at( 2 );

<a href="iterators.html">iterator</a> begin();

const char *c_str();

size_type capacity();

int compare( const basic_string &str );

int compare( const char *str ); int compare( size_type index, size_type length, const basic_string &str ); int compare( size_type index, size_type length, const basic_string &str, size_type index2, size_type length2 );

int compare( size_type index, size_type length, const char *str, size_type length2 );

size_type copy( char *str, size_type num, size_type index );

const char *data();

bool empty();

<a href="iterators.html">iterator</a> end();

<a href="iterators.html">iterator</a> erase( <a href="iterators.html">iterator</a> pos ); <a href="iterators.html">iterator</a> erase( <a href="iterators.html">iterator</a> start, <a href="iterators.html">iterator</a> end ); basic_string &erase( size_type index = 0, size_type num = npos );

string s("So, you like donuts, eh? Well, have all the donuts in the world!"); cout << "The original string is '" << s << "'" << endl;

s.erase( 50, 14 );

cout << "Now the string is '" << s << "'" << endl;

s.erase( 24 );

cout << "Now the string is '" << s << "'" << endl;

s.erase();

cout << "Now the string is '" << s << "'" << endl;

The original string is 'So, you like donuts, eh? Well, have all the donuts in the world!'

Now the string is 'So, you like donuts, eh? Well, have all the donuts'

Now the string is 'So, you like donuts, eh?'

Now the string is ''

size_type find( const basic_string &str, size_type index ); size_type find( const char *str, size_type index ); size_type find( const char *str, size_type index, size_type length ); size_type find( char ch, size_type index );

string str1( "Alpha Beta Gamma Delta" );

unsigned int loc = str1.find( "Omega", 0 ); if( loc != string::npos )

cout << "Found Omega at " << loc << endl; else

cout << "Didn't find Omega" << endl;

size_type find_first_of( const basic_string &str, size_type index = 0 ); size_type find_first_of( const char *str, size_type index = 0 ); size_type find_first_of( const char *str, size_type index, size_type num ); size_type find_first_of( char ch, size_type index = 0 );

size_type find_first_not_of( const basic_string &str, size_type index = 0 ); size_type find_first_not_of( const char *str, size_type index = 0 ); size_type find_first_not_of( const char *str, size_type index, size_type num ); size_type find_first_not_of( char ch, size_type index = 0 );

size_type find_last_of( const basic_string &str, size_type index = npos ); size_type find_last_of( const char *str, size_type index = npos ); size_type find_last_of( const char *str, size_type index, size_type num ); size_type find_last_of( char ch, size_type index = npos );

size_type find_last_not_of( const basic_string &str, size_type index = npos ); size_type find_last_not_of( const char *str, size_type index = npos); size_type find_last_not_of( const char *str, size_type index, size_type num ); size_type find_last_not_of( char ch, size_type index = npos );

allocator_type get_allocator();

<a href="iterators.html">iterator</a> insert( <a href="iterators.html">iterator</a> i, const char &ch ); basic_string &insert( size_type index, const basic_string &str ); basic_string &insert( size_type index, const char *str ); basic_string &insert( size_type index1, const basic_string &str, size_type index2, size_type num ); basic_string &insert( size_type index, const char *str, size_type num ); basic_string &insert( size_type index, size_type num, char ch ); void insert( <a href="iterators.html">iterator</a> i, size_type num, const char &ch ); void insert( <a href="iterators.html">iterator</a> i, <a href="iterators.html">iterator</a> start, <a href="iterators.html">iterator</a> end );

size_type length();

size_type max_size();

const <a href="iterators.html">reverse_iterator</a> rbegin();

const <a href="iterators.html">reverse_iterator</a> rend();

basic_string &replace( size_type index, size_type num, const basic_string &str ); basic_string &replace( size_type index1, size_type num1, const basic_string &str, size_type index2, size_type num2 );

basic_string &replace( size_type index, size_type num, const char *str ); basic_string &replace( size_type index, size_type num1, const char *str, size_type num2 ); basic_string &replace( size_type index, size_type num1, size_type num2, char ch ); basic_string &replace( <a href="iterators.html">iterator</a> start, <a href="iterators.html">iterator</a> end, const basic_string &str ); basic_string &replace( <a href="iterators.html">iterator</a> start, <a href="iterators.html">iterator</a> end, const char *str ); basic_string &replace( <a href="iterators.html">iterator</a> start, <a href="iterators.html">iterator</a> end, const char *str, size_type num ); basic_string &replace( <a href="iterators.html">iterator</a> start, <a href="iterators.html">iterator</a> end, size_type num, char ch );

string s = "They say he carved it himself...from a BIGGER spoon"; string s2 = "find your soul-mate, Homer.";

s.replace( 32, s2.length(), s2 );

cout << s << endl;

void reserve( size_type num );

void resize( size_type num );

void resize( size_type num, char ch );

size_type rfind( const basic_string &str, size_type index ); size_type rfind( const char *str, size_type index ); size_type rfind( const char *str, size_type index, size_type num ); size_type rfind( char ch, size_type index );

int loc;

string s = "My cat's breath smells like cat food.";

loc = s.rfind( "breath", 8 ); cout << "The word breath is at index " << loc << endl;

loc = s.rfind( "breath", 20 ); cout << "The word breath is at index " << loc << endl;

size_type size();

basic_string substr( size_type index, size_type num = npos );

string s("What we have here is a failure to communicate");

string sub = s.substr(21);

cout << "The original string is " << s << endl; cout << "The substring is " << sub << endl;

The original string is What we have here is a failure to communicate The substring is a failure to communicate

void swap( basic_string &str );

string first( "This comes first" );

string second( "And this is second" ); first.swap( second );

cout << first << endl; cout << second << endl;

And this is second

This comes first





stack<int> myStack;

接下来, 他只要简单的调用 push() 和 pop() 函数来操作栈. 借助 C++ 模板的威力, 他可以指定任何的数据类型，不仅仅是int类型. STL stack实现了栈的功能，而不管容纳的是什么数据类型.





cppreference.com -> C++ Bitsets





C++ Bitsets


C++ Bitsets给程序员提供一种位集合的数据结构。Bitsets使用许多二元操作符，比如逻辑和，或等。



Constructors 创建新bitsets

Operators 比较和赋值bitsets

any() 如果有任何一个位被设置就返回true

count() 返回被设置的位的个数

flip() 反转bits中的位

none() 如果没有位被设置则返回true

reset() 清空所有位

set() 设置位

size() 返回可以容纳的位的个数

test() 返回指定位的状态

to_string() 返回bitset的字符串表示

to_ulong() 返回bitset的整数表示





bitset();

bitset( unsigned long val );

// 创建一个8位长的bitset

bitset<8> bs;

// 显示这个bitset for( int i = (int) bs.size(); i >= 0; i-- ) {

cout << bs[i] << " "; }

cout << endl;

// 创建另一个bitset bitset<8> bs2( (long) 131 );

// 显示

for( int i = (int) bs2.size(); i >= 0; i-- ) {

cout << bs2[i] << " "; }

cout << endl;

!=, ==, &=, ^=, |=, ~, <<=, >>=, []

// 创建一个bitset

bitset<8> bs2( (long) 131 );

cout << "bs2 is " << bs2 << endl;

// 向左移动4位

bs2 <<= 4;

cout << "now bs2 is " << bs2 << endl;

bs2 is 10000011

now bs2 is 00110000

bool any();

size_type count();

bitset<N> &flip(); bitset<N> &flip( size_t pos ); </N></N>

bool none();

bitset<N> &reset(); bitset<N> &reset( size_t pos ); </N></N>

bitset<N> &set(); bitset<N> &set( size_t pos, int val=1 ); </N></N>

size_t size();

bool test( size_t pos );

string to_string();

unsigned long to_ulong();

to_ulong()返回bitset的无符号长整数形式。





cppreference.com -> C++ Double-Ended Queues(双向队列)





C++ Double Ended Queues(双向队列)


双向队列和向量很相似，但是它允许在容器头部快速插入和删除（就像在尾部一样）。



Constructors 创建一个新双向队列

Operators 比较和赋值双向队列

assign() 设置双向队列的值

at() 返回指定的元素

back() 返回最后一个元素

begin() 返回指向第一个元素的迭代器

clear() 删除所有元素

empty() 返回真如果双向队列为空

end() 返回指向尾部的迭代器

erase() 删除一个元素

front() 返回第一个元素

get_allocator() 返回双向队列的配置器

insert() 插入一个元素到双向队列中

max_size() 返回双向队列能容纳的最大元素个数

pop_back() 删除尾部的元素

pop_front() 删除头部的元素

push_back() 在尾部加入一个元素

push_front() 在头部加入一个元素

rbegin() 返回指向尾部的逆向迭代器

rend() 返回指向头部的逆向迭代器

resize() 改变双向队列的大小

size() 返回双向队列中元素的个数

swap() 和另一个双向队列交换元素





deque();

deque( size_type size ); deque( size_type num, const <a href="containers.html">TYPE</a> &val ); deque( const deque &from ); deque( <a href="iterators.html">input_iterator</a> start, <a href="iterators.html">input_iterator</a> end );

// 创建一个双向队列，里面有10个1

deque<int> dq( 10, 1 ); // 创建一个迭代器

deque<int>::iterator iter;

// 显示这个双向队列

for( iter = dq.begin(); iter != dq.end(); iter++ ){

cout << *iter << endl; }

</int></int>

[]

void assign( <a href="iterators.html">input_iterator</a> start, <a href="iterators.html">input_iterator</a> end); void assign( Size num, const <a href="containers.html">TYPE</a> &val );

reference at( size_type pos );

reference back();

<a href="iterators.html">iterator</a> begin();

void clear();

bool empty();

<a href="iterators.html">iterator</a> end();

<a href="iterators.html">iterator</a> erase( <a href="iterators.html">iterator</a> pos ); <a href="iterators.html">iterator</a> erase( <a href="iterators.html">iterator</a> start, <a href="iterators.html">iterator</a> end );

reference front();

allocator_type get_allocator();

<a href="iterators.html">iterator</a> insert( <a href="iterators.html">iterator</a> pos, size_type num, const <a href="containers.html">TYPE</a> &val ); void insert( <a href="iterators.html">iterator</a> pos, <a href="iterators.html">input_iterator</a> start, <a href="iterators.html">input_iterator</a> end );

size_type max_size();

void pop_back();

void pop_front();

void push_back( const <a href="containers.html">TYPE</a> &val );

void push_front( const <a href="containers.html">TYPE</a> &val );

<a href="iterators.html">reverse_iterator</a> rbegin();

<a href="iterators.html">reverse_iterator</a> rend();

void resize( size_type num, <a href="containers.html">TYPE</a> val );

size_type size();

void swap( deque &target );

swap()函数交换target和现双向队列中元素。





cppreference.com -> C++ Lists





C++ Lists（链表）


Lists将元素按顺序储存在链表中.

与 向量(vectors)相比, 它允许快速的插入和删除，但是随机访问却比较慢.





assign() 给list赋值

back() 返回最后一个元素

begin() 返回指向第一个元素的迭代器

clear() 删除所有元素

empty() 如果list是空的则返回true

end() 返回末尾的迭代器

erase() 删除一个元素

front() 返回第一个元素

get_allocator() 返回list的配置器

insert() 插入一个元素到list中

max_size() 返回list能容纳的最大元素数量

merge() 合并两个list

pop_back() 删除最后一个元素

pop_front() 删除第一个元素

push_back() 在list的末尾添加一个元素

push_front() 在list的头部添加一个元素

rbegin() 返回指向第一个元素的逆向迭代器

remove() 从list删除元素

remove_if() 按指定条件删除元素

rend() 指向list末尾的逆向迭代器

resize() 改变list的大小

reverse() 把list的元素倒转

size() 返回list中的元素个数

sort() 给list排序

splice() 合并两个list

swap() 交换两个list

unique() 删除list中重复的元素





void assign( <a href="iterators.html">input_iterator</a> start, <a href="iterators.html">input_iterator</a> end ); void assign( size_type num, const <a href="containers.html">TYPE</a> &val );

reference back();

<a href="iterators.html">iterator</a> begin();

// 创建一个元素类型是字符的链表

list<char> charList; for( int i=0; i < 10; i++ ) charList.push_front( i + 65 );

// 显示这个链表

list<char>::iterator theIterator; for( theIterator = charList.begin(); theIterator != charList.end(); theIterator++ ) cout << *theIterator;

void clear();

bool empty();

list<int> the_list;

for( int i = 0; i < 10; i++ ) the_list.push_back( i ); while( !the_list.empty() ) {

cout << the_list.front() << endl; the_list.pop_front(); }

<a href="iterators.html">iterator</a> end();

<a href="iterators.html">iterator</a> erase( <a href="iterators.html">iterator</a> pos ); <a href="iterators.html">iterator</a> erase( <a href="iterators.html">iterator</a> start, <a href="iterators.html">iterator</a> end );

reference front();

list<int> the_list;

for( int i = 0; i < 10; i++ ) the_list.push_back( i ); while( !the_list.empty() ) {

cout << the_list.front() << endl; the_list.pop_front(); }

allocator_type get_allocator();

<a href="iterators.html">iterator</a> insert( <a href="iterators.html">iterator</a> pos, const <a href="containers.html">TYPE</a> &val ); void insert( <a href="iterators.html">iterator</a> pos, size_type num, const <a href="containers.html">TYPE</a> &val ); void insert( <a href="iterators.html">iterator</a> pos, <a href="iterators.html">input_iterator</a> start, <a href="iterators.html">input_iterator</a> end );

size_type max_size();

void merge( list &lst );

void merge( list &lst, Comp compfunction );

void pop_back();

void pop_front();

void push_back( const <a href="containers.html">TYPE</a> &val );

list<int> the_list;

for( int i = 0; i < 10; i++ ) the_list.push_back( i );

void push_front( const <a href="containers.html">TYPE</a> &val );

<a href="iterators.html">reverse_iterator</a> rbegin();

void remove( const <a href="containers.html">TYPE</a> &val );

// 创建一个链表，元素是字母表的前10个元素

list<char> charList; for( int i=0; i < 10; i++ ) charList.push_front( i + 65 );

// 删除所有'E'的实例

charList.remove( 'E' );

void remove_if( UnPred pr );

<a href="iterators.html">reverse_iterator</a> rend();

void resize( size_type num, <a href="containers.html">TYPE</a> val );

void reverse();

size_type size();

void sort();

void sort( Comp compfunction );

void splice( <a href="iterators.html">iterator</a> pos, list<T,Allocator> &lst ); void splice( <a href="iterators.html">iterator</a> pos, list<T,Allocator> &lst, <a href="iterators.html">iterator</a> del ); void splice( <a href="iterators.html">iterator</a> pos, list<T,Allocator> &lst, <a href="iterators.html">iterator</a> start, <a href="iterators.html">iterator</a> end ); </T,Allocator></T,Allocator></T,Allocator>

void swap( list &lst );

void unique();

void unique( BinPred pr );

unique()函数删除链表中所有重复的元素。如果指定pr，则使用pr来判定是否删除。





cppreference.com -> C++ Maps





C++ Maps


C++ Maps是一种关联式容器，包含“关键字/值”对



begin() 返回指向map头部的迭代器

clear() 删除所有元素

count() 返回指定元素出现的次数

empty() 如果map为空则返回true

end() 返回指向map末尾的迭代器

equal_range() 返回特殊条目的迭代器对

erase() 删除一个元素

find() 查找一个元素

get_allocator() 返回map的配置器

insert() 插入元素

key_comp() 返回比较元素key的函数

lower_bound() 返回键值>=给定元素的第一个位置

max_size() 返回可以容纳的最大元素个数

rbegin() 返回一个指向map尾部的逆向迭代器

rend() 返回一个指向map头部的逆向迭代器

size() 返回map中元素的个数

swap() 交换两个map

upper_bound() 返回键值>给定元素的第一个位置

value_comp() 返回比较元素value的函数





<a href="iterators.html">iterator</a> begin();

void clear();

size_type count( const <a href="containers.html">KEY_TYPE</a> &key );

bool empty();

<a href="iterators.html">iterator</a> end();

pair<iterator, iterator=""> equal_range( const <a href="containers.html">KEY_TYPE</a> &key ); </iterator,>

void erase( <a href="iterators.html">iterator</a> pos ); void erase( <a href="iterators.html">iterator</a> start, <a href="iterators.html">iterator</a> end ); size_type erase( const <a href="containers.html">KEY_TYPE</a> &key );

<a href="iterators.html">iterator</a> find( const <a href="containers.html">KEY_TYPE</a> &key );

allocator_type get_allocator();

<a href="iterators.html">iterator</a> insert( <a href="iterators.html">iterator</a> pos, const pair<<a href="containers.html">KEY_TYPE</a>,<a href="containers.html">VALUE_TYPE</a>> &val ); void insert( <a href="iterators.html">input_iterator</a> start, <a href="iterators.html">input_iterator</a> end ); pair<iterator, bool> insert( const pair<<a href="containers.html">KEY_TYPE</a>,<a href="containers.html">VALUE_TYPE</a>> &val );

key_compare key_comp();

<a href="iterators.html">iterator</a> lower_bound( const <a href="containers.html">KEY_TYPE</a> &key );

size_type max_size();

<a href="iterators.html">reverse_iterator</a> rbegin();

<a href="iterators.html">reverse_iterator</a> rend();

size_type size();

void swap( map<Key,T,Comp,Allocator> &obj ); </Key,T,Comp,Allocator>

<a href="iterators.html">iterator</a> upper_bound( const <a href="containers.html">KEY_TYPE</a> &key );

value_compare value_comp();

value_comp()函数返回一个比较元素value的函数。





cppreference.com -> C++ Multimaps





C++ MultiMaps


C++ Multimaps和maps很相似，但是MultiMaps允许重复的元素。



begin() 返回指向第一个元素的迭代器

clear() 删除所有元素

count() 返回一个元素出现的次数

empty() 如果multimap为空则返回真

end() 返回一个指向multimap末尾的迭代器

equal_range() 返回指向元素的key为指定值的迭代器对

erase() 删除元素

find() 查找元素

get_allocator() 返回multimap的配置器

insert() 插入元素

key_comp() 返回比较key的函数

lower_bound() 返回键值>=给定元素的第一个位置

max_size() 返回可以容纳的最大元素个数

rbegin() 返回一个指向mulitmap尾部的逆向迭代器

rend() 返回一个指向multimap头部的逆向迭代器

size() 返回multimap中元素的个数

swap() 交换两个multimaps

upper_bound() 返回键值>给定元素的第一个位置

value_comp() 返回比较元素value的函数





<a href="iterators.html">iterator</a> begin();

void clear();

size_type count( const key_type &key );

bool empty();

<a href="iterators.html">iterator</a> end();

pair<iterator, iterator=""> equal_range( const key_type &key ); </iterator,>

void erase( <a href="iterators.html">iterator</a> pos ); void erase( <a href="iterators.html">iterator</a> start, <a href="iterators.html">iterator</a> end ); size_type erase( const key_type &key );

<a href="iterators.html">iterator</a> find( const key_type &key );

allocator_type get_allocator();

<a href="iterators.html">iterator</a> insert( <a href="iterators.html">iterator</a> pos, const <a href="containers.html">TYPE</a> &val ); void insert( <a href="iterators.html">input_iterator</a> start, <a href="iterators.html">input_iterator</a> end ); pair<iterator, bool=""> insert( const <a href="containers.html">TYPE</a> &val ); </iterator,>

key_compare key_comp();

<a href="iterators.html">iterator</a> lower_bound( const key_type &key );

size_type max_size();

<a href="iterators.html">reverse_iterator</a> rbegin();

<a href="iterators.html">reverse_iterator</a> rend();

size_type size();

void swap( multimap<Key,T,Comp,Allocator> &obj ); </Key,T,Comp,Allocator>

<a href="iterators.html">iterator</a> upper_bound( const key_type &key );

value_compare value_comp();

value_comp()函数返回一个比较元素value的函数。





cppreference.com -> C++ Multisets





C++ MultiSets 多元集合(MultiSets)和集合(Sets)相像，只不过支持重复对象。

begin()

返回指向第一个元素的迭代器



clear()

清除所有元素



count()

返回指向某个值元素的个数



empty()

如果集合为空，返回true



end()

返回指向最后一个元素的迭代器



equal_range()

返回集合中与给定值相等的上下限的两个迭代器



erase()

删除集合中的元素



find()

返回一个指向被查找到元素的迭代器



get_allocator()

返回多元集合的分配器



insert()

在集合中插入元素



key_comp()

返回一个用于元素间值比较的函数



lower_bound()

返回指向大于（或等于）某值的第一个元素的迭代器



max_size()

返回集合能容纳的元素的最大限值



rbegin()

返回指向多元集合中最后一个元素的反向迭代器



rend()

返回指向多元集合中第一个元素的反向迭代器



size()

多元集合中元素的数目



swap()

交换两个多元集合变量



upper_bound()

返回一个大于某个值元素的迭代器



value_comp()

返回一个用于比较元素间的值的函数





cppreference.com -> C++ Multisets -> 详细说明





C++ Multisets





begin

语法:



iterator begin();





返回指向当前集合中第一个元素的迭代器。





clear

语法:



void clear();





清除当前集合中的所有元素。





count

语法:



size_type count( const key_type &key );





返回当前集合中出现的某个值的元素的数目。





empty

语法:



bool empty();





如果当前多元集合为空，返回true；否则返回false。





end

语法:



iterator end();





返回指向当前集合中最后一个元素的迭代器。





equal_range

语法:



pair equal_range( const key_type &key );





返回集合中与给定值相等的上下限的两个迭代器。





erase

语法:



void erase( iterator pos );

void erase( iterator start, iterator end );

size_type erase( const key_type &key );





说明：

● 删除i元素；

● 删除从start开始到end结束的元素；

● 删除等于key值的所有元素（返回被删除的元素的个数）。





find

语法:



iterator find( const key_type &key );





在当前集合中查找等于key值的元素，并返回指向该元素的迭代器；如果没有找到，返回指向多元集合最后一个元素的迭代器。





get_allocator

语法:



allocator_type get_allocator();





返回当前集合的分配器。





insert

语法:



iterator insert( iterator pos, const TYPE &val );

void insert( input_iterator start, input_iterator end );

pair insert( const TYPE &val );





The function insert() either:

● 在迭代器i前插入val，并返回一个指向该元素的迭代器；

● 将迭代器start开始到end结束返回内的元素插入到集合中；

● 在当前集合中插入val元素，并返回指向该元素的迭代器和一个布尔值来说明val是否成功的被插入了。





key_comp

语法:



key_compare key_comp();





返回一个用于元素间值比较的函数对象。





lower_bound

语法:



iterator lower_bound( const key_type &key );





返回一个指向大于或者等于key值的第一个元素的迭代器。





max_size

语法:



size_type max_size();





返回当前多元集合能容纳元素的最大限值。





rbegin

语法:



reverse_iterator rbegin();





返回指向当前多元集合中最后一个元素的反向迭代器。





rend

语法:



reverse_iterator rend();





返回指向集合中第一个元素的反向迭代器。





size

语法:



size_type size();





返回当前多元集合中元素的数目。





swap

语法:



void swap( multiset &obj );





交换当前多元集合和obj多元集合中的元素。





upper_bound

语法:



iterator upper_bound( const key_type &key );





在当前多元集合中返回一个指向大于Key值的元素的迭代器





value_comp

语法:



value_compare value_comp();





返回一个用于比较元素间的值的函数对象。





cppreference.com -> C++ Priority Queues(优先队列)





C++ Priority Queues(优先队列)


C++优先队列类似队列，

但是在这个数据结构中的元素按照一定的断言排列有序。





empty() 如果优先队列为空，则返回真

pop() 删除第一个元素

push() 加入一个元素

size() 返回优先队列中拥有的元素的个数

top() 返回优先队列中有最高优先级的元素





bool empty();

void pop();

void push( const <a href="containers.html">TYPE</a> &val );

size_type size();

<a href="containers.html">TYPE</a> &top();

top()返回一个引用，指向优先队列中有最高优先级的元素。注意只有pop()函数删除一个元素。





cppreference.com -> C++ Queues (队列)





C++ Queues(队列)


C++队列是一种容器适配器，它给予程序员一种先进先出(FIFO)的数据结构。



back() 返回最后一个元素

empty() 如果队列空则返回真

front() 返回第一个元素

pop() 删除第一个元素

push() 在末尾加入一个元素

size() 返回队列中元素的个数





<a href="containers.html">TYPE</a> &back();

bool empty();

<a href="containers.html">TYPE</a> &front();

void pop();

void push( const <a href="containers.html">TYPE</a> &val );

size_type size();

size()返回队列中元素的个数。





cppreference.com -> C++ Sets





C++ Sets

集合(Set)是一种包含已排序对象的关联容器

begin()

返回指向第一个元素的迭代器



clear()

清除所有元素



count()

返回某个值元素的个数



empty()

如果集合为空，返回true



end()

返回指向最后一个元素的迭代器



equal_range()

返回集合中与给定值相等的上下限的两个迭代器



erase()

删除集合中的元素



find()

返回一个指向被查找到元素的迭代器



get_allocator()

返回集合的分配器



insert()

在集合中插入元素



lower_bound()

返回指向大于（或等于）某值的第一个元素的迭代器



key_comp()

返回一个用于元素间值比较的函数



max_size()

返回集合能容纳的元素的最大限值



rbegin()

返回指向集合中最后一个元素的反向迭代器



rend()

返回指向集合中第一个元素的反向迭代器



size()

集合中元素的数目



swap()

交换两个集合变量



upper_bound()

返回大于某个值元素的迭代器



value_comp()

返回一个用于比较元素间的值的函数





cppreference.com -> C++ Sets -> 详细说明





C++ Sets





begin

语法:



iterator begin();





返回指向当前集合中第一个元素的迭代器。





clear

语法:



void clear();





清除当前集合中的所有元素。





count

语法:



size_type count( const key_type &key );





返回当前集合中出现的某个值的元素的数目。





empty

语法:



bool empty();





如果当前集合为空，返回true；否则返回false。





end

语法:



const_iterator end();





返回指向当前集合中最后一个元素的迭代器。





equal_range

语法:



pair equal_range( const key_type &key );





返回集合中与给定值相等的上下限的两个迭代器。





erase

语法:



void erase( iterator i );

void erase( iterator start, iterator end );

size_type erase( const key_type &key );





说明：

● 删除i元素；

● 删除从start开始到end结束的元素；

● 删除等于key值的所有元素（返回被删除的元素的个数）。





find

语法:



iterator find( const key_type &key );





在当前集合中查找等于key值的元素，并返回指向该元素的迭代器；如果没有找到，返回指向集合最后一个元素的迭代器。





get_allocator

语法:



allocator_type get_allocator();





返回当前集合的分配器。





insert

语法:



iterator insert( iterator i, const TYPE &val );

void insert( input_iterator start, input_iterator end );

pair insert( const TYPE &val );





说明：

● 在迭代器i前插入val；

● 将迭代器start开始到end结束返回内的元素插入到集合中；

● 在当前集合中插入val元素，并返回指向该元素的迭代器和一个布尔值来说明val是否成功的被插入了。

（应该注意的是在集合(Sets)中不能插入两个相同的元素。)





lower_bound

语法:



iterator lower_bound( const key_type &key );





返回一个指向大于或者等于key值的第一个元素的迭代器。





key_comp

语法:



key_compare key_comp();





返回一个用于元素间值比较的函数对象。





max_size

语法:



size_type max_size();





返回当前集合能容纳元素的最大限值。





rbegin

语法:



reverse_iterator rbegin();





返回指向当前集合中最后一个元素的反向迭代器。





rend

语法:



reverse_iterator rend();





返回指向集合中第一个元素的反向迭代器。





size

语法:



size_type size();





返回当前集合中元素的数目。





swap

语法:



void swap( set &object );





交换当前集合和object集合中的元素。





upper_bound

语法:



iterator upper_bound( const key_type &key );





在当前集合中返回一个指向大于Key值的元素的迭代器。





value_comp

语法:



value_compare value_comp();





返回一个用于比较元素间的值的函数对象。





cppreference.com

-> C++ Stacks(堆栈）





C++ Stacks（堆栈）


C++ Stack（堆栈）

是一个容器类的改编，为程序员提供了堆栈的全部功能，——也就是说实现了一个先进后出（FILO）的数据结构。



操作 比较和分配堆栈

empty() 堆栈为空则返回真

pop() 移除栈顶元素

push() 在栈顶增加元素

size() 返回栈中元素数目

top() 返回栈顶元素





==

<=

>=

< > !=

bool empty();

void pop();

void push( const <a href="http://64.4.48.250/cgi-bin/containers.html">TYPE</a> &val );

stack<int> s; for( int i=0; i < 10; i++ ) s.push(i);

size_type size();

stack<int> s; for( int i=0; i < 10; i++ ) s.push(i); cout << "This stack has a size of " << s.size() << endl;

<a href="http://64.4.48.250/cgi-bin/containers.html">TYPE</a> &top();

while( !s.empty() ) {

cout << s.top() << " "; s.pop(); }

相关主题:

pop(),





cppreference.com -> C++ Vectors





C++ Vectors


Vectors 包含着一系列连续存储的元素,其行为和数组类似。访问Vector中的任意元素或从末尾添加元素都可以在常量级时间复杂度内完成，而查找特定值的元素所处的位置或是在Vector中插入元素则是线性时间复杂度。


Constructors 构造函数

Operators 对vector进行赋值或比较

assign() 对Vector中的元素赋值

at() 返回指定位置的元素

back() 返回最末一个元素

begin() 返回第一个元素的迭代器

capacity() 返回vector所能容纳的元素数量(在不重新分配内存的情况下）

clear() 清空所有元素

empty() 判断Vector是否为空（返回true时为空）

end() 返回最末元素的迭代器(译注:实指向最末元素的下一个位置)

erase() 删除指定元素

front() 返回第一个元素

get_allocator() 返回vector的内存分配器

insert() 插入元素到Vector中

max_size() 返回Vector所能容纳元素的最大数量（上限）

pop_back() 移除最后一个元素

push_back() 在Vector最后添加一个元素

rbegin() 返回Vector尾部的逆迭代器

rend() 返回Vector起始的逆迭代器

reserve() 设置Vector最小的元素容纳数量

resize() 改变Vector元素数量的大小

size() 返回Vector元素数量的大小

swap() 交换两个Vector





vector();

vector( size_type num, const <a href="containers.html">TYPE</a> &val ); vector( const vector &from ); vector( <a href="iterators.html">input_iterator</a> start, <a href="iterators.html">input_iterator</a> end );

vector<int> v1( 5, 42 );

v1 == v2

v1 != v2

v1 <= v2

v1 >= v2

v1 < v2

v1 > v2

v[]

void assign( <a href="iterators.html">input_iterator</a> start, <a href="iterators.html">input_iterator</a> end ); void assign( size_type num, const <a href="containers.html">TYPE</a> &val );

<a href="containers.html">TYPE</a> at( size_type loc );

vector<int> v( 5, 1 );



for( int i = 0; i < 10; i++ ) {

cout << "Element " << i << " is " << v[i] << endl; }

vector<int> v( 5, 1 );



for( int i = 0; i < 10; i++ ) {

cout << "Element " << i << " is " << v.at(i) << endl; }

<a href="containers.html">TYPE</a> back();

vector<int> v;



for( int i = 0; i < 5; i++ ) {

v.push_back(i); }



cout << "The first element is " << v.front() << " and the last element is " << v.back() << endl;

The first element is 0 and the last element is 4

<a href="iterators.html">iterator</a> begin();

vector<int> v1( 5, 789 );

vector<int>::iterator it;

for( it = v1.begin(); it != v1.end(); it++ ) cout << *it << endl;

size_type capacity();

void clear();

bool empty();

vector<int> v;



for( int i = 0; i < 5; i++ ) {

v.push_back(i); }



while( !v.empty() ) {

cout << v.back() << endl; v.pop_back(); }

<a href="iterators.html">iterator</a> end();

<a href="iterators.html">iterator</a> erase( <a href="iterators.html">iterator</a> loc ); <a href="iterators.html">iterator</a> erase( <a href="iterators.html">iterator</a> start, <a href="iterators.html">iterator</a> end );

erase函数要么删作指定位置loc的元素,要么删除区间[start, end)的所有元素.返回值是指向删除的最后一个元素的下一位置的迭代器.例如: <p></p>



// 创建一个vector,置入字母表的前十个字符

vector<char> alphaVector;

for( int i=0; i < 10; i++ )

alphaVector.push_back( i + 65 ); int size = alphaVector.size();



vector<char>::iterator startIterator; vector<char>::iterator tempIterator;

for( int i=0; i < size; i++ )

{

tartIterator = alphaVector.begin(); alphaVector.erase( startIterator );

// Display the vector for( tempIterator = alphaVector.begin(); tempIterator != alphaVector.end(); tempIterator++ ) cout << *tempIterator; cout << endl; }





BCDEFGHIJ


CDEFGHIJ


DEFGHIJ


EFGHIJ


FGHIJ


GHIJ


HIJ


IJ


J


<a href="containers.html">TYPE</a> front();

allocator_type get_allocator();

<a href="iterators.html">iterator</a> insert( <a href="iterators.html">iterator</a> loc, const <a href="containers.html">TYPE</a> &val ); void insert( <a href="iterators.html">iterator</a> loc, size_type num, const <a href="containers.html">TYPE</a> &val ); void insert( <a href="iterators.html">iterator</a> loc, <a href="iterators.html">input_iterator</a> start, <a href="iterators.html">input_iterator</a> end );

//创建一个vector,置入字母表的前十个字符

vector<char> alphaVector;

for( int i=0; i < 10; i++ )

alphaVector.push_back( i + 65 );

//插入四个C到vector中

vector<char>::iterator theIterator = alphaVector.begin(); alphaVector.insert( theIterator, 4, 'C' );

//显示vector的内容

for( theIterator = alphaVector.begin(); theIterator != alphaVector.end(); theIterator++ ) cout << *theIterator;





CCCCABCDEFGHIJ


size_type max_size();

void pop_back();

vector<char> alphaVector;

for( int i=0; i < 10; i++ )

alphaVector.push_back( i + 65 );

int size = alphaVector.size();

vector<char>::iterator theIterator; for( int i=0; i < size; i++ ) {

alphaVector.pop_back(); for( theIterator = alphaVector.begin(); theIterator != alphaVector.end(); theIterator++ ) cout << *theIterator; cout << endl; }





ABCDEFGHI


ABCDEFGH


ABCDEFG


ABCDEF


ABCDE


ABCD


ABC


AB


A


void push_back( const <a href="containers.html">TYPE</a> &val );

<a href="iterators.html">reverse_iterator</a> rbegin();

<a href="iterators.html">reverse_iterator</a> rend();

void reserve( size_type size );

void resize( size_type size, <a href="containers.html">TYPE</a> val );

size_type size();

void swap( vector &from );

swap()函数交换当前vector与vector from的元素





vector<int> the_vector;

vector<int>::iterator the_iterator;

for( int i=0; i < 10; i++ ) the_vector.push_back(i);

int total = 0; the_iterator = the_vector.begin(); while( the_iterator != the_vector.end() ) {

total += *the_iterator; the_iterator++; }

cout << "Total=" << total << endl;

提示：通过对一个迭代器的解引用操作（*），可以访问到容器所包含的元素。





cppreference.com -> 所有的 C 函数





所有的 C 函数





abort

abs

acos

asctime

asin

assert

atan

atan2

atexit

atof

atoi

atol

bsearch

calloc

ceil

clearerr

clock

cos

cosh

ctime

difftime

div

exit

exp

fabs

fclose

feof

ferror

fflush

fgetc

fgetpos

fgets

floor

fmod

fopen

fprintf

fputc

fputs

fread

free

freopen

frexp

fscanf

fseek

fsetpos

ftell

fwrite

getc

getchar

getenv

gets

gmtime

isalnum

isalpha

iscntrl

isdigit

isgraph

islower

isprint

ispunct

isspace

isupper

isxdigit

labs

ldexp

ldiv

localtime

log

log10

longjmp

malloc

memchr

memcmp

memcpy

memmove

memset

mktime

modf

perror

pow

printf

putc

putchar

puts

qsort

raise

rand

realloc

remove

rename

rewind

scanf

setbuf

setjmp

setvbuf

signal

sin

sinh

sprintf

sqrt

srand

sscanf

strcat

strchr

strcmp

strcoll

strcpy

strcspn

strerror

strftime

strlen

strncat

strncmp

strncpy

strpbrk

strrchr

strspn

strstr

strtod

strtok

strtol

strtoul

strxfrm

system

tan

tanh

time

tmpfile

tmpnam

tolower

toupper

ungetc

va_arg

vprintf, vfprintf,





cppreference.com -> 所有的 C++ 函数





所有的 C++ 函数





Constructors (deque)

Constructors (bitset)

Constructors (string)

Constructors (vector)

Operators (deque)

Operators (stack)

Operators (string)

Operators (vector)

any (bitset)

append (string)

assign (deque)

assign (list)

assign (string)

assign (vector)

at (deque)





at (string)





at (vector)





back (deque)

back (list)





back (queue)

back (vector)

bad (io)





begin (deque)

begin (list)

begin (map)





begin (multimap)

begin (multiset)

begin (set)





begin (string)

begin (vector)

c_str (string)

capacity (string)

capacity (vector)

clear (deque)

clear (io)





clear (list)

clear (map)





clear (multimap)

clear (multiset)

clear (set)





clear (vector)

compare (string)

copy (string)

count (bitset)

count (map)





count (multimap)

count (multiset)

count (set)





data (string)

empty (deque)

empty (list)

empty (map)





empty (multimap)

empty (multiset)

empty (priorityqueue)

empty (queue)

empty (set)





empty (stack)

empty (string)

empty (vector)

end (deque)





end (list)





end (map)





end (multimap)

end (multiset)

end (set)





end (string)

end (vector)

eof (io)





equal_range (map)

equal_range (multimap)

equal_range (multiset)

equal_range (set)

erase (deque)

erase (list)

erase (map)





erase (multimap)

erase (multiset)

erase (set)





erase (string)

erase (vector)

fail (io)





fill (io)





find (map)





find (multimap)

find (multiset)

find (set)





find (string)

find_first_not_of (string)

find_first_of (string)

find_last_not_of (string)

find_last_of (string)

flags (io)





flip (bitset)

flush (io)





front (deque)

front (list)

front (queue)

front (vector)

fstream (io)

gcount (io)





get (io)





get_allocator (deque)

get_allocator (list)

get_allocator (map)

get_allocator (multimap)

get_allocator (multiset)

get_allocator (set)

get_allocator (string)

get_allocator (vector)

getline (io)

good (io)





ignore (io)





insert (deque)

insert (list)

insert (map)

insert (multimap)

insert (multiset)

insert (set)

insert (string)

insert (vector)

key_comp (map)

key_comp (multimap)

key_comp (multiset)

key_comp (set)

length (string)

lower_bound (map)

lower_bound (multimap)

lower_bound (multiset)

lower_bound (set)

max_size (deque)

max_size (list)

max_size (map)

max_size (multimap)

max_size (multiset)

max_size (set)

max_size (string)

max_size (vector)

merge (list)

none (bitset)

open (io)





peek (io)





pop (priorityqueue)

pop (queue)





pop (stack)





pop_back (deque)

pop_back (list)

pop_back (vector)

pop_front (deque)

pop_front (list)

precision (io)

push (priorityqueue)

push (queue)

push (stack)

push_back (deque)

push_back (list)

push_back (vector)

push_front (deque)

push_front (list)

put (io)





putback (io)

rbegin (deque)

rbegin (list)

rbegin (map)

rbegin (multimap)

rbegin (multiset)

rbegin (set)

rbegin (string)

rbegin (vector)

rdstate (io)

read (io)





remove (list)

remove_if (list)

rend (deque)

rend (list)





rend (map)





rend (multimap)

rend (multiset)

rend (set)





rend (string)

rend (vector)

replace (string)

reserve (string)

reserve (vector)

reset (bitset)

resize (deque)

resize (list)

resize (string)

resize (vector)

reverse (list)

rfind (string)

seekg (io)





seekp (io)





set (bitset)

setf (io)





size (bitset)

size (deque)

size (list)





size (map)





size (multimap)

size (multiset)

size (priorityqueue)

size (queue)

size (set)





size (stack)

size (string)

size (vector)

sort (list)





splice (list)

substr (string)

swap (deque)

swap (list)





swap (map)





swap (multimap)

swap (multiset)

swap (set)





swap (string)

swap (vector)

sync_with_stdio (io)

tellg (io)





tellp (io)





test (bitset)

to_string (bitset)

to_ulong (bitset)

top (priorityqueue)

top (stack)





unique (list)

unsetf (io)





upper_bound (map)

upper_bound (multimap)

upper_bound (multiset)

upper_bound (set)

value_comp (map)

value_comp (multimap)

value_comp (multiset)

value_comp (set)

width (io)





write (io)





cppreference.com -> 所有的 C / C++ 函数





所有的 C / C++ 函数





Constructors (cppstring)

Constructors (cppvector)

Operators (cppbitset)

Operators (cppdeque)

Operators (cppstack)

Operators (cppstring)

Operators (cppvector)

abort (stdother)

abs (stdmath)





acos (stdmath)





any (cppbitset)

append (cppstring)

asctime (stddate)

asin (stdmath)





assert (stdother)

assign (cppdeque)

assign (cpplist)

assign (cppstring)

assign (cppvector)

at (cppdeque)





at (cppstring)





at (cppvector)





atan (stdmath)





atan2 (stdmath)

atexit (stdother)

atof (stdstring)

atoi (stdstring)

atol (stdstring)

back (cppdeque)

back (cpplist)





back (cppqueue)

back (cppvector)

bad (cppio)





begin (cppdeque)

begin (cpplist)

begin (cppmap)





begin (cppmultimap)

begin (cppmultiset)

begin (cppset)





begin (cppstring)

begin (cppvector)

bsearch (stdother)

c_str (cppstring)

calloc (stdmem)

capacity (cppstring)

capacity (cppvector)

ceil (stdmath)





clear (cppdeque)

clear (cppio)





clear (cpplist)

clear (cppmap)





clear (cppmultimap)

clear (cppmultiset)

clear (cppset)





clear (cppvector)

clearerr (stdio)

clock (stddate)

compare (cppstring)

copy (cppstring)

cos (stdmath)





cosh (stdmath)





count (cppbitset)

count (cppmap)





count (cppmultimap)

count (cppmultiset)

count (cppset)





ctime (stddate)

data (cppstring)

#define (preproc)

difftime (stddate)

div (stdmath)





empty (cppdeque)

empty (cpplist)

empty (cppmap)





empty (cppmultimap)

empty (cppmultiset)

empty (cpppriorityqueue)

empty (cppqueue)

empty (cppset)





empty (cppstack)

empty (cppstring)

empty (cppvector)

end (cppdeque)





end (cpplist)





end (cppmap)





end (cppmultimap)

end (cppmultiset)

end (cppset)





end (cppstring)

end (cppvector)

eof (cppio)





equal_range (cppmap)

equal_range (cppmultimap)

equal_range (cppmultiset)

equal_range (cppset)

erase (cppdeque)

erase (cpplist)

erase (cppmap)





erase (cppmultimap)

erase (cppmultiset)

erase (cppset)





erase (cppstring)

erase (cppvector)

#error (preproc)

exit (stdother)

exp (stdmath)





fabs (stdmath)





fail (cppio)





fclose (stdio)





feof (stdio)





ferror (stdio)





fflush (stdio)





fgetc (stdio)





fgetpos (stdio)

fgets (stdio)





fill (cppio)





find (cppmap)





find (cppmultimap)

find (cppmultiset)

find (cppset)





find (cppstring)

find_first_not_of (cppstring)

find_first_of (cppstring)

find_last_not_of (cppstring)

find_last_of (cppstring)

flags (cppio)





flip (cppbitset)

floor (stdmath)

flush (cppio)





fmod (stdmath)





fopen (stdio)





fprintf (stdio)

fputc (stdio)





fputs (stdio)





fread (stdio)





free (stdmem)





freopen (stdio)

frexp (stdmath)

front (cppdeque)

front (cpplist)

front (cppqueue)

front (cppvector)

fscanf (stdio)





fseek (stdio)





fsetpos (stdio)

fstream (cppio)

ftell (stdio)





fwrite (stdio)





gcount (cppio)





get (cppio)





get_allocator (cppdeque)

get_allocator (cpplist)

get_allocator (cppmap)

get_allocator (cppmultimap)

get_allocator (cppmultiset)

get_allocator (cppset)

get_allocator (cppstring)

get_allocator (cppvector)

getc (stdio)





getchar (stdio)

getenv (stdother)

getline (cppio)

gets (stdio)





gmtime (stddate)

good (cppio)





(preproc)





ignore (cppio)

#include (preproc)

insert (cppdeque)

insert (cpplist)

insert (cppmap)

insert (cppmultimap)

insert (cppmultiset)

insert (cppset)

insert (cppstring)

insert (cppvector)

isalnum (stdstring)

isalpha (stdstring)

iscntrl (stdstring)

isdigit (stdstring)

isgraph (stdstring)

islower (stdstring)

isprint (stdstring)

ispunct (stdstring)

isspace (stdstring)

isupper (stdstring)

isxdigit (stdstring)

key_comp (cppmap)

key_comp (cppmultimap)

key_comp (cppmultiset)

key_comp (cppset)

labs (stdmath)





ldexp (stdmath)

ldiv (stdmath)





length (cppstring)

#line (preproc)





localtime (stddate)

log (stdmath)





log10 (stdmath)

longjmp (stdother)

lower_bound (cppmap)

lower_bound (cppmultimap)

lower_bound (cppmultiset)

lower_bound (cppset)

malloc (stdmem)

max_size (cppdeque)

max_size (cpplist)

max_size (cppmap)

max_size (cppmultimap)

max_size (cppmultiset)

max_size (cppset)

max_size (cppstring)

max_size (cppvector)

memchr (stdstring)

memcmp (stdstring)

memcpy (stdstring)

memmove (stdstring)

memset (stdstring)

merge (cpplist)

mktime (stddate)

modf (stdmath)





none (cppbitset)

open (cppio)





peek (cppio)





perror (stdio)





pop (cpppriorityqueue)

pop (cppqueue)





pop (cppstack)





pop_back (cppdeque)

pop_back (cpplist)

pop_back (cppvector)

pop_front (cppdeque)

pop_front (cpplist)

pow (stdmath)





#pragma (preproc)

precision (cppio)

Predefined variables (preproc)

printf (stdio)





push (cpppriorityqueue)

push (cppqueue)

push (cppstack)

push_back (cppdeque)

push_back (cpplist)

push_back (cppvector)

push_front (cppdeque)

push_front (cpplist)

put (cppio)





putback (cppio)

putc (stdio)





putchar (stdio)

puts (stdio)





qsort (stdother)

raise (stdother)

rand (stdother)

rbegin (cppdeque)

rbegin (cpplist)

rbegin (cppmap)

rbegin (cppmultimap)

rbegin (cppmultiset)

rbegin (cppset)

rbegin (cppstring)

rbegin (cppvector)

rdstate (cppio)

read (cppio)





realloc (stdmem)

remove (cpplist)

remove (stdio)





remove_if (cpplist)

rename (stdio)





rend (cppdeque)

rend (cpplist)





rend (cppmap)





rend (cppmultimap)

rend (cppmultiset)

rend (cppset)





rend (cppstring)

rend (cppvector)

replace (cppstring)

reserve (cppstring)

reserve (cppvector)

reset (cppbitset)

resize (cppdeque)

resize (cpplist)

resize (cppstring)

resize (cppvector)

reverse (cpplist)

rewind (stdio)





rfind (cppstring)

scanf (stdio)





seekg (cppio)





seekp (cppio)





set (cppbitset)

setbuf (stdio)





setf (cppio)





setjmp (stdother)

setvbuf (stdio)

#, ## (preproc)

signal (stdother)

sin (stdmath)





sinh (stdmath)





size (cppbitset)

size (cppdeque)

size (cpplist)





size (cppmap)





size (cppmultimap)

size (cppmultiset)

size (cpppriorityqueue)

size (cppqueue)

size (cppset)





size (cppstack)

size (cppstring)

size (cppvector)

sort (cpplist)





splice (cpplist)

sprintf (stdio)

sqrt (stdmath)





srand (stdother)

sscanf (stdio)





strcat (stdstring)

strchr (stdstring)

strcmp (stdstring)

strcoll (stdstring)

strcpy (stdstring)

strcspn (stdstring)

strerror (stdstring)

strftime (stddate)

strlen (stdstring)

strncat (stdstring)

strncmp (stdstring)

strncpy (stdstring)

strpbrk (stdstring)

strrchr (stdstring)

strspn (stdstring)

strstr (stdstring)

strtod (stdstring)

strtok (stdstring)

strtol (stdstring)

strtoul (stdstring)

strxfrm (stdstring)

substr (cppstring)

swap (cppdeque)

swap (cpplist)





swap (cppmap)





swap (cppmultimap)

swap (cppmultiset)

swap (cppset)





swap (cppstring)

swap (cppvector)

sync_with_stdio (cppio)

system (stdother)

tan (stdmath)





tanh (stdmath)





tellg (cppio)





tellp (cppio)





test (cppbitset)

time (stddate)





tmpfile (stdio)

tmpnam (stdio)





to_string (cppbitset)

to_ulong (cppbitset)

tolower (stdstring)

top (cpppriorityqueue)

top (cppstack)





toupper (stdstring)

#undef (preproc)

ungetc (stdio)





unique (cpplist)

unsetf (cppio)





upper_bound (cppmap)

upper_bound (cppmultimap)

upper_bound (cppmultiset)

upper_bound (cppset)

va_arg (stdother)

value_comp (cppmap)

value_comp (cppmultimap)

value_comp (cppmultiset)

value_comp (cppset)

vprintf, vfprintf, (stdio)

width (cppio)

write (cppio)





cppreference.com -> 感谢

此文档英文原文摘自www.cppreference.com

以下C-Free的支持者，为文档的翻译做出贡献，特此感谢：

Dreamby , sirius , Vic Zhang , Lauren.Jc , Rexzhou , power , littlestone





cppreference.com -> Static Return





Watch out.


This function returns a variable that is statically located, and therefore overwritten each time this function is called. If you want to save the return value of this function, you should manually save it elsewhere.



Of course, when you save it elsewhere, you should make sure to actually copy the value(s) of this variable to another location. If the return value is a struct, you should make a new struct, then copy over the members of the struct.





cout.setf(ios::left);

cout << dec;

<iostream>中定义的操作符

操作符描述输入 	输出

boolalpha 启用boolalpha标志 	 X X

dec 启用dec标志 X 	 X

endl 输出换行标示，并清空缓冲区 	 X

ends 输出空字符 	 X

fixed 启用fixed标志 	 X

flush 清空流 	 X

hex 启用 hex 标志 	 X X

internal 启用 internal 标志 	 X

left 启用 left 标志 	 X

noboolalpha 关闭boolalpha 标志 	 X X

noshowbase 关闭showbase 	标志 X

noshowpoint 关闭showpoint 标志 	 X

noshowpos 关闭showpos 标志 	 X

noskipws 关闭skipws 标志 	 X

nounitbuf 关闭unitbuf 标志 	 X

nouppercase 关闭uppercase 标志 	 X

oct 启用 oct 标志 	 X X

right 启用 right 标志 	 X

scientific 启用 	scientific 标志 X

showbase 启用 showbase 标志 	 X

showpoint 启用 showpoint 	标志 X

showpos 启用 showpos 标志 	 X

skipws 启用 skipws 标志 	 X

unitbuf 启用 unitbuf 标志 	 X

uppercase 启用 uppercase 	标志 X

ws 跳过所有前导空白字符 X

在<iomanip>中定义的操作符

操作符描述输入输出

resetiosflags( long f ) 关闭被指定为f的标志 X X

setbase( int base ) 设置数值的基本数为base X

setfill( int ch ) 设置填充字符为ch X

setiosflags( long f ) 启用指定为f的标志 X X

setprecision( int p ) 设置数值的精度 X

setw( int w ) 设置域宽度为w X





vector<int> v;

只要容器中的对象能够满足如下条件，C++容器既能够容纳C++内建的类型对象 (像上面例子中的 int 类型) 也能够自定义的对象: 对象必须有默认构造函数,

有一个可访问的析构函数, 并且

有一个可访问的赋值操作符重载函数(operator=).



当我们在本文档中描述各种容器的功能的时候, 我们用 TYPE 来表示容器所包含的数据的类型. 例如, 在上面例子中, TYPE 表示 int.





cppreference.com -> Complexity





Complexity


There are different measurements of the speed of any given algorithm. Given an input size of N, they can be described as follows:





Name Speed Description



exponential time slow takes an amount of time proportional to a constant raised to the Nth power (K^N)



polynomial time fast takes an amount of time proportional to N raised to some constant power (N^K)



linear time faster takes an amount of time directly proportional to N

(K * N)





logarithmic time much faster takes an amount of time proportional to the logarithm of

N (log(N))





constant time fastest takes a fixed amount of time, no matter how large the input is (K)





